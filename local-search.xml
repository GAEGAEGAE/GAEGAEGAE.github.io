<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편</title>
    <link href="/2021/09/06/LinuxKernelBasic3/"/>
    <url>/2021/09/06/LinuxKernelBasic3/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-3-커널에서의-메모리-할당-1편"><a href="#Research-Linux-Kernel-Basic-3-커널에서의-메모리-할당-1편" class="headerlink" title="[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편"></a>[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 리눅스 커널(Linux Kernel)에서도 연산을 수행하기 위해서 데이터가 저장되어야만 하는 공간이 있어야 한다. 이러한 공간의 주체는 메모리(memory)이며 리눅스 커널(Linux Kernel)에서의 메모리의 할당 방식을 알아본다.</p><h2 id="정적-메모리"><a href="#정적-메모리" class="headerlink" title="정적 메모리"></a>정적 메모리</h2><p>커널에서의 정적 메모리 할당에 대하여 구체적으로 알아보려고 한다. 유저 공간의 할당과 마찬가지로 정적 메모리 할당은 특징을 지닌다.</p></br><pre><code>1. 함수 호출 시 함수 프롤로그의 절차를 통해 스택에 공간을 할당한다.2. 유저 공간과는 별개의 커널의 스택 공간이 할당된다.3. 컴파일 시 스택 공간에 얼마만큼의 데이터를 활용할 것인지에 관해 결정된다.4. 함수 호출 시 함수 에필로그의 절차를 통해 정적 메모리는 자동으로 해제된다.</code></pre><p>위의 기재된 내용은 일반적인 유저공간의 스택공간의 할당과 동일해보인다. 부가적인 내용을 붙히자면 컴파일을 통해 스택 프레임의 최상위에서 sub연산을 통해 공간을 확보하고 함수 호출이 종료되는 시점에서 스택 프레임의 최상위에서 add연산을 통해 프레임을 해제한다. 이 후 함수가 호출되어도 스택 포인터(frame pointer)와 베이스 포인터(base pointer)를 기준으로 접근하기에 일반적인 경우라면 문제 발생의 소지가 없다.</p></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task) &#123;<br>    int prio, oldprio, queued, running, queue_flag =<br>        DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;<br>    const struct sched_class *prev_class;<br>    struct rq_flags rf;<br>    struct rq *rq;<br><br>    prio = __rt_effective_prio(pi_task, p-&gt;normal_prio);<br>    ...<br></code></pre></td></tr></table></figure><p>다음의 코드를 확인하면 8개의 변수를 활용하는 것을 알 수 있다.</p></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">&lt;rt_mutex_setprio&gt;:<br>    e1a0c00d movip, sp<br>    e92ddff0 push&#123;r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc&#125;<br>    e24cb004 subfp, ip, #4<br>    e24dd014 subsp, sp, #20<br>    .<br>    .<br>    .<br></code></pre></td></tr></table></figure><p>해당 함수의 어셈블리 코드를 확인하면 레지스터 {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}를 스택 공간에 push하며 sub sp, sp, #20을 통해 스택의 20바이트의 공간 만큼을 확보한다. 이 때 사용되는 지역변수의 개수는 8개이며 32바이트 만큼의 공간을 확보해야 한다고 의문이 드나 이는 내부적으로 레지스터를 활용하는 방안으로 진행되지 않았을까라고 조심스럽게 판단한다. 자세한 부분은 b30w0lf님께 여쭤봐야 할 것으로 보인다.</p><h2 id="동적-메모리"><a href="#동적-메모리" class="headerlink" title="동적 메모리"></a>동적 메모리</h2><p>커널에서의 동적 메모리 할당에 대하여 구체적으로 알아보려고 한다. 커널에서의 메모리 할당은 kmalloc() 함수를 이용하여 동적 메모리를 할당한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,<br>   unsigned int to, char __user *user_buf, size_t count, loff_t *ppos)<br>    &#123;<br>    ...<br>    if (*ppos &lt; 0 || !count)<br>    return -EINVAL;<br><br>    buf = kmalloc(count, GFP_KERNEL);<br>    if (!buf)<br>    return -ENOMEM;<br></code></pre></td></tr></table></figure><p>상단의 코드를 확인하면 kmalloc() 함수를 볼 수 있으며 해당 함수는 두 개의 인자 count와 GFP_KERNEL이 전달되는 것을 확인할 수 있다. 종합해 코드를 해석하면 GFP_KERNEL 옵션을 통해 count 바이트 만큼 동적 메모리를 할당한다라는 의미이다. kmalloc을 이용하면 커널 내부 메모리 시스템의 경우 커널 내부에 할당할 동적 메모리가 있으면 최대한 할당해준다고 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>정적 메모리의 할당은 유저 공간(user space)에서의 스택 공간할당은 커널 메모리 공간에 할당된다. 이외에는 크게 다른 점이 없어보이며 동적 메모리 할당은 kmalloc() 함수를 사용한다이다. 단 의아한 부분이 커널 내부에 할당할 동적 메모리가 있으면 최대한 할당해준다고 하는 의미인다. 이는 슬랩(slab)에 대한 개념을 익혀야 더욱 깊게 이해가 가능할 것으로 보인다.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p>해당 자료는 <a href="http://rousalome.egloos.com/10002615%EB%A5%BC">http://rousalome.egloos.com/10002615를</a> 기반으로 학습하여 작성하였습니다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (2) 태스크(task)</title>
    <link href="/2021/09/05/LinuxKernelBasic2/"/>
    <url>/2021/09/05/LinuxKernelBasic2/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-2-태스크-task"><a href="#Research-Linux-Kernel-Basic-2-태스크-task" class="headerlink" title="[Research] Linux Kernel Basic - (2) 태스크(task)"></a>[Research] Linux Kernel Basic - (2) 태스크(task)</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>지난 포스트에서는 리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대해 간략히 언급하였다. 해당 포스트에서는 운영체제(Operating System)에서 다뤄지는 프로세스(prcoess)와 스레드(thread)를 정의하는 구조인 태스크(task)를 커널 소스코드 분석을 통해 심도있게 이해하고 해당 과정을 통해 어떠한 방식으로 권한확대(Local Privilege Escalation)를 일으킬 수 있는 가에 관한 인사이트를 얻기 위한 연구를 진행하였다.</p><h2 id="프로세스-proces-및-스레드-thread"><a href="#프로세스-proces-및-스레드-thread" class="headerlink" title="프로세스(proces) 및 스레드(thread)"></a>프로세스(proces) 및 스레드(thread)</h2><pre><code>$ ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:50 ?        00:00:02 /sbin/init auto nopromptroot          2      0  0 01:50 ?        00:00:00 [kthreadd]root          3      2  0 01:50 ?        00:00:00 [rcu_gp]root          4      2  0 01:50 ?        00:00:00 [rcu_par_gp]root          6      2  0 01:50 ?        00:00:00 [kworker/0:0H-kb]root          9      2  0 01:50 ?        00:00:00 [mm_percpu_wq]root         10      2  0 01:50 ?        00:00:00 [ksoftirqd/0]root         11      2  0 01:50 ?        00:00:00 [rcu_sched]root         12      2  0 01:50 ?        00:00:00 [migration/0]root         13      2  0 01:50 ?        00:00:00 [idle_inject/0]</code></pre><p>리눅스를 사용하다보면 다음과 같은 명령어를 통해 프로세스의 정보를 확인해야하는 경우가 발생한다. 프로세스의 정보를 확인하면 어떠한 프로세스인지, 프로세스의 번호는 몇번인지, 어떠한 권한으로 동작을 진행하는지에 관한 정보들을 확인할 수 있다. 리눅스에서는 프로세스에 종속되어 새로운 실행의 흐름을 생성하는 스레드(thread)의 경우에도 하나의 프로그램의 실행단위로 볼 수 있으며 이러한 단위를 태스크(task)라고 한다.</p><h2 id="태스크-task"><a href="#태스크-task" class="headerlink" title="태스크(task)"></a>태스크(task)</h2><p>리눅스 운영체제의 경우 컴퓨터가 해야할 작업의 단위인 여러 개의 태스크(task)를 생성하며 다수의 태스크를 관리(multitasking)하며 이러한 태스크의 실행 시간을 배분하는 방식(scheduling)을 통해 사용자가 다수의 프로그램을 정상적으로 사용할 수 있도록 한다. 태스크를 관리하기 위해서는 여러가지 정보가 필요하다. 이는 앞서 제시하였던 명령어의 결과로 일부를 확인할 수 있다. 이러한 정보는 task_struct 구조체에 정의되어 있으며 해당 구조체는 &lt;include/linux/sched.h&gt;에서 확인할 수 있다.</p><h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="cred"><a href="#cred" class="headerlink" title="cred"></a>cred</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct cred &#123;<br>atomic_tusage;<br>    ...<br>kuid_tuid;/* real UID of the task */<br>kgid_tgid;/* real GID of the task */<br>kuid_tsuid;/* saved UID of the task */<br>kgid_tsgid;/* saved GID of the task */<br>kuid_teuid;/* effective UID of the task */<br>kgid_tegid;/* effective GID of the task */<br>kuid_tfsuid;/* UID for VFS ops */<br>kgid_tfsgid;/* GID for VFS ops */<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>usage</td><td>몇 개의 프로세스가 해당 cred 구조체를 참조하고 있는 지 나타낸 정보이다.</td></tr><tr><td>uid</td><td>프로세스를 소유하고 있는 사용자의 ID를 나타낸 정보이다. 0일 경우 최고관리자 권한을 의미한다.</td></tr><tr><td>euid</td><td>프로세스의 실효적인 사용자 ID를 나타낸 정보이다. 권한 검사를 할 경우 실제 사용되는 값을 저장한다. 일반적으로 uid와 같은 값을 가진다.</td></tr><tr><td>gid</td><td>프로세스를 소유하 고 있는 그룹의 ID 정보를 나타낸다.</td></tr><tr><td>egid</td><td>프로세스의 실효적인 그룹의 ID 정보를 나타낸다.</td></tr></tbody></table><h2 id="credential-정보-수정을-통한-권한-상승"><a href="#credential-정보-수정을-통한-권한-상승" class="headerlink" title="credential 정보 수정을 통한 권한 상승"></a>credential 정보 수정을 통한 권한 상승</h2><p>앞서 진행한 과정을 통해 프로세스와 스레드는 태스크라는 단위로 관리되어 있고 태스크의 정보 속성을 관리하는 주체가 있으며 신원정보는 cred라는 구조체에서 관리되고 있음을 알 수 있다. 그렇다면 태스크의 신원정보를 변경하였을 경우 권한 상승(Local Privilege Escalation)이 이뤄질 수 있는 지 확인하겠다. </p><p>해당 실습은 Dreamhack에서 제시하는 실습 파일을 이용하여 진행하였음을 밝힌다.</p><pre><code>dreamhack@dh-lke:~$ whoamidreamhackdreamhack@dh-lke:~$ cat /etc/shadowcat: /etc/shadow: Permission denieddreamhack@dh-lke:~$ echo $$295dreamhack@dh-lke:~$ ...</code></pre><p>qemu를 이용하여 터미널을 실행하였을 경우 다음과 같이 root 권한이 아니기 때문에 /etc/shadow 파일을 볼 수 없는 것을 확인할 수 있으며 해당 쉘의 프로세스 아이디(PID)는 295로 확인된다.</p><pre><code>pwndbg&gt; x/bs $lx_task_by_pid(295).comm0xffff88803e348a98:    &quot;bash&quot;pwndbg&gt; print $lx_task_by_pid(295).state$1 = 1pwndbg&gt; print $lx_task_by_pid(295).cred-&gt;uid$2 = &#123;    val = 1000&#125;pwndbg&gt; set $lx_task_by_pid(295).cred-&gt;euid = 0pwndbg&gt; cont</code></pre><p>해당 프로세스의 아이디를 이용하여 해당 태스크의 정보를 확인해본 결과 해당 프로세스는 실행중인 프로세스이며 uid가 1000으로 지정되어 있다. 이를 의도적으로 0으로 수정해보았다.</p><pre><code>dreamhack@dh-lke:~$ whoamirootdreamhack@dh-lke:~$ cat /etc/shadowroot:*:18511:0:99999:7:::daemon:*:18511:0:99999:7:::bin:*:18511:0:99999:7:::sys:*:18511:0:99999:7:::sync:*:18511:0:99999:7:::games:*:18511:0:99999:7:::man:*:18511:0:99999:7:::lp:*:18511:0:99999:7:::mail:*:18511:0:99999:7:::</code></pre><p>해당 과정을 수행해본 결과 해당 프로세스는 최고 관리자 권한(root)를 획득하였음을 볼 수 있다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>프로세스(process)와 스레드(thread)는 태스크 관리로 운영되며 태스크의 속성을 표현하는 정보가 있다. 해당 정보 중에는 프로세스의 신원정보를 의미하는 cred 구조체 형태의 정보가 있으며 이를 조작하여 최고관리자 권한을 얻을 수 있다. 태스크의 정보는 커널 메모리의 상주하며 커널의 취약점을 이용한다면 권한상승(Local Privilege Escalation)이 발생할 수 있음을 보인다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</title>
    <link href="/2021/09/04/LinuxKernelBasic1/"/>
    <url>/2021/09/04/LinuxKernelBasic1/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-1-유저모드와-커널모드"><a href="#Research-Linux-Kernel-Basic-1-유저모드와-커널모드" class="headerlink" title="[Research] Linux Kernel Basic - (1) 유저모드와 커널모드"></a>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대한 이해가 먼저 선행되어야 한다. 하지만 리눅스 커널(Linux Kernel)은 일반적으로 접근한다면 오픈소스의 특성인 집단지성의 결정체라고 할 수 있을만큼 매우 방대하며 모든 것을 학습을 할 수 없다. 그러므로 리눅스 커널 공격(Linux Kernel Exploitation)을 위한 기초적인 운영체제의 지식을 기반으로하여 프로세스의 메모리 구조, 유저모드(user mode)와 커널모드(kernel mode), 커널의 공격할 수 있는 부분(attack surface)가 될 수 있는 많은 부분 중 쉽게 구현할 수 있는 디바이스 드라이버(device driver)를 기반으로 연구를 진행했다.</p><h2 id="커널-kernel-이란"><a href="#커널-kernel-이란" class="headerlink" title="커널(kernel)이란"></a>커널(kernel)이란</h2><p><img src="/img/arch.png"></p><p>공격할 대상은 리눅스 커널(linux kernel)이다. 그렇다면 커널(kernel)이 무엇인지 확인하고 넘어갈 필요가 있다. 컴퓨터(computer)는 흔히 알고 있는 전기적으로 제어할 수 있는 CPU, Memory, Devices들로 이루어진 일종의 기계장치(machine)으로 볼 수 있다. 기계란 어떠한 방식으로 동작되는 지 사람이 지정해주어야 하며 기계의 특성상 프로그램을 실행할 수 있도록 섬세하게 조정이 되어야 한다. 그렇지 않다면 단순한 실리콘 덩어리들의 불과하다. 다음과 같은 이유를 고려하면 어떻게 이러한 실리콘 덩어리를 잘 활용하여야 흔히 사용하는 프로그램을 돌리기 위해서는 어떠한 동작이 정의되어 있어야 한다. 커널(kernel)은 다음과 같은 역할을 하기에 중간계층이라고도 많이 불리운다.</p><h2 id="메모리-memory-란"><a href="#메모리-memory-란" class="headerlink" title="메모리(memory)란"></a>메모리(memory)란</h2><p><img src="/img/process_memory.png"></p><p>프로그램이 실행되기 위해서는 보조기억장치(HDD, SSD등)에서 주기억장치(RAM)에 로드 되어야 한다. 하나의 프로세스가 로드되면 32bit를 예시로 총 4GB의 가상메모리 공간에 위치하게 된다. 상단에 제시한 그림과 같은 형태를 나타낸다. 상위 주소(0xC0000000 ~ 0xFFFFFFFF)에는 커널의 위치한 주소가 되며 하위 주소(0x00000000~0xBFFFFFFFF)에는 흔히 알고 있는 유저 프로세스가 로드된다. 커널의 경우는 앞서 언급한 것과 같이 하드웨어의 직접적으로 접근할 수 있는 중요한 부분이며 이러한 이유로 스택 메모리를 확인하면 높은 주소에서 낮은 주소로 데이터가 쓰이는 것을 볼 수 있다.</p><h2 id="커널의-권한"><a href="#커널의-권한" class="headerlink" title="커널의 권한"></a>커널의 권한</h2><p><img src="/img/two_rise_sun.PNG" alt="하늘아래 태양은 두개가 될 수 없는 법."></p><p>커널은 프로세스들을 관리하기도 하고 주요한 정보들이 위치하기에 일반적으로 높은 권한을 지니고 있다. 그럼 다른 이야기를 해보자! 서로 친해지기 위해서 술게임을 하며 왕게임을 하는 데 가학적 성격장애가 있는 친구에게 권력이 부여된다면 타겟들은 인생이 힘들어진다. 또한 아무나 왕이 될 수 있다고하면 배가 산으로 가게되며 시스템 상에서는 아주 큰 문제가 발생할 수 있다. 그러므로 시스템에서는 특권을 지닌 커널 모드와 제한된 권한인 유저 모드로 나누어져 있다.</p><h2 id="커널에게-일을-시키고-싶어-시스템콜-syscall"><a href="#커널에게-일을-시키고-싶어-시스템콜-syscall" class="headerlink" title="커널에게 일을 시키고 싶어 - 시스템콜(syscall)"></a>커널에게 일을 시키고 싶어 - 시스템콜(syscall)</h2><p><img src="/img/systemcall.PNG"></p><p>그렇다면 어떻게 하면 커널을 공격할 수 있을 지 고민해보아야 한다. 일반적으로 유저 권한을 지닌 사용자 어플리케이션을 생각해보면 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 커널도 마찬가지이다. 커널에서의 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 이를 공격 표면(attack surface)라고 불린다. 가장 손쉽게 접근이 가능한 부분은 시스템 콜(syscall)이라고 볼 수 있다. 유저 모드에서는 직접적으로 컴퓨터의 중요 자원에 접근할 수 없기 때문에 커널 모드로의 전환이 일어나야 한다. 흔히 사용하는 printf와 같이 화면에 출력을 하는 함수의 경우도 저수준 함수로 변환되어 커널에게 시스템 콜이라는 인터럽트(interrupt)를 발생시키게 된다. </p><h2 id="커널의-공격-대상-attack-vector"><a href="#커널의-공격-대상-attack-vector" class="headerlink" title="커널의 공격 대상(attack vector)"></a>커널의 공격 대상(attack vector)</h2><p>커널의 주요한 자원에 접근하기 위해서는 직접적으로 접근할 수 없으며 시스템 콜과 같은 간접적인 형태로 접근할 수 있음을 언급하였다. 또한 정의된 시스템 콜 이외에도 리눅스의 경우 디바이스 드라이버 또는 파일 시스템이 모두 커널 모드에서 동작된다. 이러한 요소들까지 고려하면 리눅스의 attack surface의 경우는 시스템 콜 뿐만이 아닌 블루투스 디바이스 드라이버와 같은 많은 형태로 확장이 가능하다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Etc] G4EG4EG4E는 왜 이 블로그를 만들었는가?</title>
    <link href="/2021/09/03/gaelog-introduction/"/>
    <url>/2021/09/03/gaelog-introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험"><a href="#G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험" class="headerlink" title="G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험"></a>G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험</h2><p><img src="/img/introduction.PNG"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>항상 글은 첫 시작이 어렵다. 글 뿐만 아니라 모든 것이 첫 시작이 어렵다. 기존의 개인적으로 운영하던 블로그가 존재하였으나 너무 시대에 뒤떨어진(?) 플랫폼에서 운영되며 나는 간지로 먹고사는 개발자이기 때문에 유행에 따르게 되어 새로운 블로그를 시작하게 되었다. </p><p>사실은 회사의 마케팅 채널로 기술 블로그를 운영할 시점이기도 하였으며 앞으로 진행할 연구로 인해서 연구노트를 작성해야 하였으며 평소 내가 사모(?)하던 (이하 ‘b40W0lF’)님께서 연구노트처럼 블로그 작성을 권해주셨으며 무한히 신뢰하기 때문에 해당 의견대로 블로그 글을 작성하겠다.</p><p>사랑합니다! 프로페써!!!</p>]]></content>
    
    
    <categories>
      
      <category>Etc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sample1</tag>
      
      <tag>Sample2</tag>
      
      <tag>Sample3</tag>
      
      <tag>Sample4</tag>
      
      <tag>Sample5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
