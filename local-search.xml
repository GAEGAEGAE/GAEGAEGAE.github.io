<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (2) 태스크(task)</title>
    <link href="/2021/09/04/LinuxKernelBasic2/"/>
    <url>/2021/09/04/LinuxKernelBasic2/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-2-태스크-task"><a href="#Research-Linux-Kernel-Basic-2-태스크-task" class="headerlink" title="[Research] Linux Kernel Basic - (2) 태스크(task)"></a>[Research] Linux Kernel Basic - (2) 태스크(task)</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>지난 포스트에서는 리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대해 간략히 언급하였다. 해당 포스트에서는 운영체제(Operating System)에서 다뤄지는 프로세스(prcoess)와 스레드(thread)를 정의하는 구조인 태스크(task)를 커널 소스코드 분석을 통해 심도있게 이해하고 해당 과정을 통해 어떠한 방식으로 권한확대(Local Privilege Escalation)를 일으킬 수 있는 가에 관한 인사이트를 얻기 위한 연구를 진행하였다.</p><h2 id="프로세스-proces-및-스레드-thread"><a href="#프로세스-proces-및-스레드-thread" class="headerlink" title="프로세스(proces) 및 스레드(thread)"></a>프로세스(proces) 및 스레드(thread)</h2><pre><code>$ ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:50 ?        00:00:02 /sbin/init auto nopromptroot          2      0  0 01:50 ?        00:00:00 [kthreadd]root          3      2  0 01:50 ?        00:00:00 [rcu_gp]root          4      2  0 01:50 ?        00:00:00 [rcu_par_gp]root          6      2  0 01:50 ?        00:00:00 [kworker/0:0H-kb]root          9      2  0 01:50 ?        00:00:00 [mm_percpu_wq]root         10      2  0 01:50 ?        00:00:00 [ksoftirqd/0]root         11      2  0 01:50 ?        00:00:00 [rcu_sched]root         12      2  0 01:50 ?        00:00:00 [migration/0]root         13      2  0 01:50 ?        00:00:00 [idle_inject/0]</code></pre><p>리눅스를 사용하다보면 다음과 같은 명령어를 통해 프로세스의 정보를 확인해야하는 경우가 발생한다. 프로세스의 정보를 확인하면 어떠한 프로세스인지, 프로세스의 번호는 몇번인지, 어떠한 권한으로 동작을 진행하는지에 관한 정보들을 확인할 수 있다. 리눅스에서는 프로세스에 종속되어 새로운 실행의 흐름을 생성하는 스레드(thread)의 경우에도 하나의 프로그램의 실행단위로 볼 수 있으며 이러한 단위를 태스크(task)라고 한다.</p><h2 id="태스크-task"><a href="#태스크-task" class="headerlink" title="태스크(task)"></a>태스크(task)</h2><p>리눅스 운영체제의 경우 컴퓨터가 해야할 작업의 단위인 여러 개의 태스크(task)를 생성하며 다수의 태스크를 관리(multitasking)하며 이러한 태스크의 실행 시간을 배분하는 방식(scheduling)을 통해 사용자가 다수의 프로그램을 정상적으로 사용할 수 있도록 한다. 태스크를 관리하기 위해서는 여러가지 정보가 필요하다. 이는 앞서 제시하였던 명령어의 결과로 일부를 확인할 수 있다. 이러한 정보는 task_struct 구조체에 정의되어 있으며 해당 구조체는 &lt;include/linux/sched.h&gt;에서 확인할 수 있다.</p><h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="cred"><a href="#cred" class="headerlink" title="cred"></a>cred</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct cred &#123;<br>atomic_tusage;<br>    ...<br>kuid_tuid;/* real UID of the task */<br>kgid_tgid;/* real GID of the task */<br>kuid_tsuid;/* saved UID of the task */<br>kgid_tsgid;/* saved GID of the task */<br>kuid_teuid;/* effective UID of the task */<br>kgid_tegid;/* effective GID of the task */<br>kuid_tfsuid;/* UID for VFS ops */<br>kgid_tfsgid;/* GID for VFS ops */<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>usage</td><td>몇 개의 프로세스가 해당 cred 구조체를 참조하고 있는 지 나타낸 정보이다.</td></tr><tr><td>uid</td><td>프로세스를 소유하고 있는 사용자의 ID를 나타낸 정보이다. 0일 경우 최고관리자 권한을 의미한다.</td></tr><tr><td>euid</td><td>프로세스의 실효적인 사용자 ID를 나타낸 정보이다. 권한 검사를 할 경우 실제 사용되는 값을 저장한다. 일반적으로 uid와 같은 값을 가진다.</td></tr><tr><td>gid</td><td>프로세스를 소유하 고 있는 그룹의 ID 정보를 나타낸다.</td></tr><tr><td>egid</td><td>프로세스의 실효적인 그룹의 ID 정보를 나타낸다.</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</title>
    <link href="/2021/09/04/LinuxKernelBasic1/"/>
    <url>/2021/09/04/LinuxKernelBasic1/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-1-유저모드와-커널모드"><a href="#Research-Linux-Kernel-Basic-1-유저모드와-커널모드" class="headerlink" title="[Research] Linux Kernel Basic - (1) 유저모드와 커널모드"></a>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</h2><p><img src="/img/little_penguin.jpg"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대한 이해가 먼저 선행되어야 한다. 하지만 리눅스 커널(Linux Kernel)은 일반적으로 접근한다면 오픈소스의 특성인 집단지성의 결정체라고 할 수 있을만큼 매우 방대하며 모든 것을 학습을 할 수 없다. 그러므로 리눅스 커널 공격(Linux Kernel Exploitation)을 위한 기초적인 운영체제의 지식을 기반으로하여 프로세스의 메모리 구조, 유저모드(user mode)와 커널모드(kernel mode), 커널의 공격할 수 있는 부분(attack surface)가 될 수 있는 많은 부분 중 쉽게 구현할 수 있는 디바이스 드라이버(device driver)를 기반으로 연구를 진행했다.</p><h2 id="커널-kernel-이란"><a href="#커널-kernel-이란" class="headerlink" title="커널(kernel)이란"></a>커널(kernel)이란</h2><p><img src="/img/arch.png"></p><p>공격할 대상은 리눅스 커널(linux kernel)이다. 그렇다면 커널(kernel)이 무엇인지 확인하고 넘어갈 필요가 있다. 컴퓨터(computer)는 흔히 알고 있는 전기적으로 제어할 수 있는 CPU, Memory, Devices들로 이루어진 일종의 기계장치(machine)으로 볼 수 있다. 기계란 어떠한 방식으로 동작되는 지 사람이 지정해주어야 하며 기계의 특성상 프로그램을 실행할 수 있도록 섬세하게 조정이 되어야 한다. 그렇지 않다면 단순한 실리콘 덩어리들의 불과하다. 다음과 같은 이유를 고려하면 어떻게 이러한 실리콘 덩어리를 잘 활용하여야 흔히 사용하는 프로그램을 돌리기 위해서는 어떠한 동작이 정의되어 있어야 한다. 커널(kernel)은 다음과 같은 역할을 하기에 중간계층이라고도 많이 불리운다.</p><h2 id="메모리-memory-란"><a href="#메모리-memory-란" class="headerlink" title="메모리(memory)란"></a>메모리(memory)란</h2><p><img src="/img/process_memory.png"></p><p>프로그램이 실행되기 위해서는 보조기억장치(HDD, SSD등)에서 주기억장치(RAM)에 로드 되어야 한다. 하나의 프로세스가 로드되면 32bit를 예시로 총 4GB의 가상메모리 공간에 위치하게 된다. 상단에 제시한 그림과 같은 형태를 나타낸다. 상위 주소(0xC0000000 ~ 0xFFFFFFFF)에는 커널의 위치한 주소가 되며 하위 주소(0x00000000~0xBFFFFFFFF)에는 흔히 알고 있는 유저 프로세스가 로드된다. 커널의 경우는 앞서 언급한 것과 같이 하드웨어의 직접적으로 접근할 수 있는 중요한 부분이며 이러한 이유로 스택 메모리를 확인하면 높은 주소에서 낮은 주소로 데이터가 쓰이는 것을 볼 수 있다.</p><h2 id="커널의-권한"><a href="#커널의-권한" class="headerlink" title="커널의 권한"></a>커널의 권한</h2><p><img src="/img/two_rise_sun.PNG" alt="하늘아래 태양은 두개가 될 수 없는 법."></p><p>커널은 프로세스들을 관리하기도 하고 주요한 정보들이 위치하기에 일반적으로 높은 권한을 지니고 있다. 그럼 다른 이야기를 해보자! 서로 친해지기 위해서 술게임을 하며 왕게임을 하는 데 가학적 성격장애가 있는 친구에게 권력이 부여된다면 타겟들은 인생이 힘들어진다. 또한 아무나 왕이 될 수 있다고하면 배가 산으로 가게되며 시스템 상에서는 아주 큰 문제가 발생할 수 있다. 그러므로 시스템에서는 특권을 지닌 커널 모드와 제한된 권한인 유저 모드로 나누어져 있다.</p><h2 id="커널에게-일을-시키고-싶어-시스템콜-syscall"><a href="#커널에게-일을-시키고-싶어-시스템콜-syscall" class="headerlink" title="커널에게 일을 시키고 싶어 - 시스템콜(syscall)"></a>커널에게 일을 시키고 싶어 - 시스템콜(syscall)</h2><p><img src="/img/systemcall.PNG"></p><p>그렇다면 어떻게 하면 커널을 공격할 수 있을 지 고민해보아야 한다. 일반적으로 유저 권한을 지닌 사용자 어플리케이션을 생각해보면 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 커널도 마찬가지이다. 커널에서의 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 이를 공격 표면(attack surface)라고 불린다. 가장 손쉽게 접근이 가능한 부분은 시스템 콜(syscall)이라고 볼 수 있다. 유저 모드에서는 직접적으로 컴퓨터의 중요 자원에 접근할 수 없기 때문에 커널 모드로의 전환이 일어나야 한다. 흔히 사용하는 printf와 같이 화면에 출력을 하는 함수의 경우도 저수준 함수로 변환되어 커널에게 시스템 콜이라는 인터럽트(interrupt)를 발생시키게 된다. </p><h2 id="커널의-공격-대상-attack-vector"><a href="#커널의-공격-대상-attack-vector" class="headerlink" title="커널의 공격 대상(attack vector)"></a>커널의 공격 대상(attack vector)</h2><p>커널의 주요한 자원에 접근하기 위해서는 직접적으로 접근할 수 없으며 시스템 콜과 같은 간접적인 형태로 접근할 수 있음을 언급하였다. 또한 정의된 시스템 콜 이외에도 리눅스의 경우 디바이스 드라이버 또는 파일 시스템이 모두 커널 모드에서 동작된다. 이러한 요소들까지 고려하면 리눅스의 attack surface의 경우는 시스템 콜 뿐만이 아닌 블루투스 디바이스 드라이버와 같은 많은 형태로 확장이 가능하다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Mitigation - (1) KASLR part1</title>
    <link href="/2021/09/03/Linux-Kernel-KASLR/"/>
    <url>/2021/09/03/Linux-Kernel-KASLR/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Mitigation-1-KASLR-part1"><a href="#Research-Linux-Kernel-Mitigation-1-KASLR-part1" class="headerlink" title="[Research] Linux Kernel Mitigation - (1) KASLR part1"></a>[Research] Linux Kernel Mitigation - (1) KASLR part1</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>작성중…</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Etc] G4EG4EG4E는 왜 이 블로그를 만들었는가?</title>
    <link href="/2021/09/03/gaelog-introduction/"/>
    <url>/2021/09/03/gaelog-introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험"><a href="#G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험" class="headerlink" title="G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험"></a>G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험</h2><p><img src="/img/introduction.PNG"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>항상 글은 첫 시작이 어렵다. 글 뿐만 아니라 모든 것이 첫 시작이 어렵다. 기존의 개인적으로 운영하던 블로그가 존재하였으나 너무 시대에 뒤떨어진(?) 플랫폼에서 운영되며 나는 간지로 먹고사는 개발자이기 때문에 유행에 따르게 되어 새로운 블로그를 시작하게 되었다. </p><p>사실은 회사의 마케팅 채널로 기술 블로그를 운영할 시점이기도 하였으며 앞으로 진행할 연구로 인해서 연구노트를 작성해야 하였으며 평소 내가 사모(?)하던 (이하 ‘b40W0lF’)님께서 연구노트처럼 블로그 작성을 권해주셨으며 무한히 신뢰하기 때문에 해당 의견대로 블로그 글을 작성하겠다.</p><p>사랑합니다! 프로페써!!!</p>]]></content>
    
    
    <categories>
      
      <category>Etc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sample1</tag>
      
      <tag>Sample2</tag>
      
      <tag>Sample3</tag>
      
      <tag>Sample4</tag>
      
      <tag>Sample5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
