<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (7) 디바이스 드라이버(Device Driver) 2편</title>
    <link href="/2021/09/09/LinuxKernelBasic7/"/>
    <url>/2021/09/09/LinuxKernelBasic7/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-7-디바이스-드라이버-Device-Driver-2편"><a href="#Research-Linux-Kernel-Basic-7-디바이스-드라이버-Device-Driver-2편" class="headerlink" title="[Research] Linux Kernel Basic - (7) 디바이스 드라이버(Device Driver) 2편"></a>[Research] Linux Kernel Basic - (7) 디바이스 드라이버(Device Driver) 2편</h2><p><img src="/img/penguinshot.png"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>지난 포스트에서는 커널의 종류인 모놀리식 커널과 마이크로 커널을 알아보았으며 적재 가능 모듈(LKM)이 어떠한 것 인지, 적재 가능 모듈(LKM)으로 사용되는 디바이스 드라이버에 대해 언급하였다. 해당 포스트에서는 캐릭터 디바이스 드라이버(Character Device Driver)를 직접 구현해보며 연구한 것을 토대로 포스트를 작성하겠다.</p></br><h2 id="디바이스-드라이버"><a href="#디바이스-드라이버" class="headerlink" title="디바이스 드라이버"></a>디바이스 드라이버</h2><p><img src="/img/device_driver_graph.PNG"></p><p>디바이스 드라이버의 경우 디바이스 자체에 대한 정보를 세부적으로 알 필요가 없으며 가상파일시스템(VFS)을 이용하여 파일에 대한 접근을 통해 디바이스를 제어할 수 있다. 해당 말을 일반적으로 풀어내면 디바이스 드라이버의 경우 추상화된 장치에 접근하여 정형화 된 인터페이스(open, read, write)과 같은 형태로 접근이 가능하다는 말이다.</p><h3 id="User-Application-측면"><a href="#User-Application-측면" class="headerlink" title="User Application 측면"></a>User Application 측면</h3><ul><li>하드웨어 장치, 즉 디바이스의 경우 하나의 파일로 인식할 수 있다.</li><li>정형화된 인터페이스 시스템 호출을 통해 실제 하드웨어 장치에 대한 접근/제어가 가능하다.</li></ul><h3 id="Operating-System-측면"><a href="#Operating-System-측면" class="headerlink" title="Operating System 측면"></a>Operating System 측면</h3><ul><li>리눅스에서 디바이스는 파일로 취급되며 액세스가 가능하다.</li><li>파일로 취급되므로 정의된 file operation을 기준으로 접근/제어가 가능하다.</li><li>각각의 디바이스는 디바이스를 식별하기 위한 Major Number와 Minor Number를 가지고 있다.</li></ul><h3 id="Major-Number-amp-Minor-Number"><a href="#Major-Number-amp-Minor-Number" class="headerlink" title="Major Number &amp; Minor Number"></a>Major Number &amp; Minor Number</h3><pre><code>$ ls -al /dev/*crw-rw----   1 root tty       7,   0 Sep  5 17:33 vcscrw-rw----   1 root tty       7,   1 Sep  5 17:33 vcs1crw-rw----   1 root tty       7,   2 Sep  5 17:33 vcs2crw-rw----   1 root tty       7,   3 Sep  5 17:33 vcs3crw-rw----   1 root tty       7,   4 Sep  5 17:33 vcs4crw-rw----   1 root tty       7,   5 Sep  5 17:33 vcs5crw-rw----   1 root tty       7,   6 Sep  5 17:33 vcs6.</code></pre><p>Major Number(주번호)의 경우는 커널에서 디바이스 드라이버를 구분/연결하는 용도로 사용되며 같은 디바이스 종류를 지칭한다. 1byte로 구성된다. Minor Number(부번호)의 경우는 디바이스 드라이버 내에 장치를 구분하기 위해 사용되며 각 디바이스의 부가적인 정보를 나타내며 2byte로 구성된다. 이를 통해 하나의 디바이스 드라이버가 여러 개의 디바이스를 제어 가능하다.</p></br><h2 id="모듈-프로그래밍"><a href="#모듈-프로그래밍" class="headerlink" title="모듈 프로그래밍"></a>모듈 프로그래밍</h2><h3 id="chardev-c"><a href="#chardev-c" class="headerlink" title="chardev.c"></a>chardev.c</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">// source: chardev.c<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/kernel.h&gt;<br><br>MODULE_AUTHOR(&quot;G4EG4EG4E&quot;);<br>MODULE_DESCRIPTION(&quot;sample character device driver.&quot;);<br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br><br>static int __init custom_init(void) &#123;<br>    printk(&quot;[+] Init Custom Device\n&quot;);<br><br>    return 0;<br><br>&#125;<br><br>static void __exit custom_exit(void) &#123;<br>    printk(&quot;[-] Exit Custom Device\n&quot;);<br>&#125;<br><br><br>module_init(custom_init);<br>module_exit(custom_exit);<br><br></code></pre></td></tr></table></figure><p>다음과 같은 디바이스 드라이버 모듈을 작성하였다. module_init의 경우는 해당 모듈이 등록될 경우 실행되는 함수이며, module_exit의 경우는 해당 모듈이 해제될 경우 실행되는 함수이다.</p></br><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-m += chardev.o<br>PWD := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br><br>KDIR:=/lib/modules/<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span>/build<br><br><span class="hljs-section">all:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> clean<br></code></pre></td></tr></table></figure><p>모듈의 소스코드를 컴파일하기 위해서는 Makefile을 작성해야 한다. 커널 버전과 동일한 형태로 빌드를 진행해야 해당 시스템에서 동적으로 로드할 수 있는 모듈이 된다. 컴파일이 정상적으로 될 경우 chardev.ko 바이너리를 확인할 수 있으며 해당 바이너리가 LKM이다.</p></br><h3 id="커널-모듈의-등록과-해제"><a href="#커널-모듈의-등록과-해제" class="headerlink" title="커널 모듈의 등록과 해제"></a>커널 모듈의 등록과 해제</h3><pre><code>$ sudo insmod chardev.ko$ dmesg [301222.511894] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301222.511896] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623243] atkbd serio0: Unknown key pressed (translated set 2, code 0x72 on isa0060/serio0).[301226.623250] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623564] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301226.623566] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301300.320388] [+] Init Custom Device.</code></pre><p>insmod 명령어를 통해 해당 커널 모듈을 등록할 경우 custom_init 함수가 실행되는 것을 확인할 수 있다.</p></br><pre><code>$ sudo rmmod chardev$ dmesg [301222.511894] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301222.511896] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623243] atkbd serio0: Unknown key pressed (translated set 2, code 0x72 on isa0060/serio0).[301226.623250] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301226.623564] atkbd serio0: Unknown key released (translated set 2, code 0x72 on isa0060/serio0).[301226.623566] atkbd serio0: Use &#39;setkeycodes 72 &lt;keycode&gt;&#39; to make it known.[301300.320388] [+] Init Custom Device[301311.542920] [-] Exit Custom Device.</code></pre><p>rmmod 명령어를 통해 해당 커널 모듈을 해제할 경우 custom_exit 함수가 실행되는 것을 확인할 수 있다.</p></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>아몬드 넥스트 레벨💁</code></pre><br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)https://butter-shower.tistory.com/29?category=715664</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (6) 디바이스 드라이버(Device Driver) 1편</title>
    <link href="/2021/09/08/LinuxKernelBasic6/"/>
    <url>/2021/09/08/LinuxKernelBasic6/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-6-디바이스-드라이버-Device-Driver-1편"><a href="#Research-Linux-Kernel-Basic-6-디바이스-드라이버-Device-Driver-1편" class="headerlink" title="[Research] Linux Kernel Basic - (6) 디바이스 드라이버(Device Driver) 1편"></a>[Research] Linux Kernel Basic - (6) 디바이스 드라이버(Device Driver) 1편</h2><p><img src="/img/penguinshot.png"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 모놀리식 커널과 마이크로 커널을 알아보고 리눅스 커널(Linux Kernel)은 어떠한 특성을 지니며 리눅스 커널 모듈(LKM)에 대한 설명을 진행하며 디바이스 드라이버를 직접 개발하여 직접 커널에 탑재해보는 연구를 진행하며 얻은 결과에 대한 포스팅을 진행하겠다.</p></br><h2 id="모놀리식-커널과-마이크로-커널"><a href="#모놀리식-커널과-마이크로-커널" class="headerlink" title="모놀리식 커널과 마이크로 커널"></a>모놀리식 커널과 마이크로 커널</h2><p><img src="/img/kernel.png" alt="커널의 종류"></p><p>커널이란 운영체제의 핵심이 되는 소프트웨어이며 메인 메모리에 상주하여 시스템의 존재하는 자원을 효율적으로 관리하는 역할을 한다는 이야기를 언급하였다. 예를 들어 프로세스의 우선순위를 통해 컨텍스트 스위칭 시 어떤 프로세스를 실행시킬 것 인지 관리도 하며 가상 메모리를 통해 하드 디스크에서 프로그램을 로드할 경우 메모리를 할당하거나 하는 등의 사용자가 컴퓨터를 사용할 경우 내부적으로 하드웨어의 접근을 통해 결정을 하는 등의 주요 역할을 한다. </p><p>그러한 커널에도 크게 두 가지 종류의 커널이 있다고 볼 수 있다. <u>모놀리식 커널(Monolithic Kernel)</u>과 <u>마이크로 커널(Micro Kernel)</u>이다. 모놀리식 커널의 경우는 시스템 기능인 (VFS, IPC, Device Driver)등과 같은 기능들을 커널이 수행하는 역할을 하지만 마이크로 커널(Micro Kernel)의 경우에는 운영체제로서 진행해야하는 핵심적인 기능(스케줄링, 메모리 관리)등의 기능만 커널에 담아 가벼운 형태로 만든 커널이다. 상단의 그림을 보면 기존에 커널이 제공해야만 한다고 생각하였던 File Systems, Process Server등이 User Space에서 돌아가고 있음을 볼 수 있다.</p><p>각 커널의 특성에 따라서 장단점을 가지고 있으며 모놀리식 커널에 특성상 주요 컴포넌트들이 커널에 위치하기에 커널 내부의 요소들이 복합적으로 상호작용을 하는 것이 간결하여 빠르다. 하지만 주요기능이 커널에 존재하여 메모리 충돌과 같은 이슈가 발생하면 커널 패닉(Kernel Panic)이 발생하며 시스템 자체가 종료된다. 마이크로 커널의 경우는 하드웨어 종속성을 최소화 시킨 형태로 핵심적인 기능만을 진행하기에 이식성이 높으며 새로운 기능을 추가할 경우 서버를 추가하는 방식으로 진행되기에 확장성이 좋다. 하지만 서로 다른 영역인 User Mode와 Kernel Mode의 빈번한 전환(Context Swithcing)이 발생하며 전체 속도면에서는 좋지 않다는 단점이 있다.</p></br><h2 id="적재-가능-커널-모듈-LKM"><a href="#적재-가능-커널-모듈-LKM" class="headerlink" title="적재 가능 커널 모듈(LKM)"></a>적재 가능 커널 모듈(LKM)</h2><p>리눅스 커널은 앞서 이야기한 커널 중 모놀리식 커널(Monolithic Kernel)이다. 일반적으로 모놀리식 커널의 단점은 디바이스 드라이버와 같은 커널 모듈을 추가/삭제하기 위해서는 커널을 재빌드 해야 한다고 한다. 하지만 다음과 같은 경우에는 얼마나 큰 불편함이 생길지 고민해보겠다. 하드웨어는 커널에 근접되어 있으며 커널은 유저모드에서 분리되어 있다. 그렇기에 하드웨어를 제어하기 위해서는 유저 모드에서 커널에 요청을 보내서 제어하는 간접적인 형태로 볼 수 있다. 결과적으로 해당 디바이스를 제어하기 위해서는 커널에 탑재가 되어 있어야 한다.</p><p>현재는 전 세계가 메타버스 코인에 탑승하여 다양한 형태의 새로운 하드웨어 주변 장치들이 출시되고 있다. 그럴 경우마다 리눅스 커널에 해당 디바이스 드라이버를 포함하여 빌드한다면 절대로 끝나지 않는 무간지옥에 빠지는 꼴이 된다. 또한 커널을 필요할 때는 사용하고 필요하지 않을 때는 사용하지 않도록 메모리에 로드하거나 로드하지 않도록 한다면 이에 따른 이점도 생긴다. 이러한 불편함을 리눅스에서 제공하는 기능인 적재 가능 커널 모듈(Loadable Kernel Module)이다.</p><p>적재 가능 커널 모듈(Loadable Kernel Module)이란 보다 자유롭게 커널에 등록하거나 해제하거나를 통해서 손쉽게 다룰 수 있다. 일반적으로 LKM(Loadable Kernel Module)이 사용되는 경우는 다음과 같다. </p><pre><code>디바이스 드라이버(Device Driver)파일 시스템 드라이버(Filesystem Driver)시스템 콜(System Call)네트워크 드라이버(Network Driver)터미널 드라이버(TTY line disciplines)실행가능한 인터프리터(Executable Interpreters)</code></pre><p>다음에 제시된 일반적인 용도를 살펴보면 새로운 장치의 디바이스 드라이버만을 이야기하는 것이 아닌 사용자가 정의한 형태의 시스템 콜도 모듈로 탑재가 가능하다는 것이다. 이러한 생각도 가능한 데 만약 권한상승 공격이 KASLR이나 여러가지 요소로 Exploit 자체가 확률적으로 수행된다면 루트 권한을 얻은 시점에서 특정 시스템 콜을 사용하면 루트 권한을 획득하는 형태로 모듈을 등록해놓는다면 매번 Exploit을 진행할 필요가 없이 성공적으로 권한 상승을 수행할 수 있다. 이러한 것이 일반적으로 언급되는 루트킷(rootkit)이다.</p><p>그렇다면 마이크로 커널(Micro Kernel)과 다른 점이 무엇이냐고 할 수 있다. 해당 언급은 어디에서도 찾아볼 수 없는 데 <u>내가 생각하고 느낀 바로 가장 큰 차이점은 어떠한 영역에 커널이 탑재되냐는 것</u>이다. 마이크로 커널(Micro Kernel)의 경우 디바이스 드라이버와 같은 기능들은 유저 영역의 메모리에 상주한다고 하면 적재 가능 커널 모듈(LKM)은 커널 영역에 로드가 되므로 이는 모놀리식 커널(Monolithic Kernel)의 확장으로 이해하는 것이 맞음으로 판단된다. 그렇지 않다면 Kernel Exploitation을 위한 공격 벡터로 볼 수 없기에 해당 포스트는 무의미한 포스트가 된다.</p></br><h2 id="디바이스-드라이버"><a href="#디바이스-드라이버" class="headerlink" title="디바이스 드라이버"></a>디바이스 드라이버</h2><p><img src="/img/device_driver_sample.PNG" alt="커널의 종류"></p><p>이전 단락에서 LKM(Loadable Kernel Module)에 대해서 언급하였으며 해당 단락에서는 일반적으로 LKM으로 구현되는 디바이스 드라이버에 대한 언급을 진행하겠다. 다시 한번 강조하지만 <u>유저 어플리케이션은 직접적으로 하드웨어를 제어할 수 없다.</u> 커널에 요청을 하여 하드웨어를 제어해야 하며 이러한 매개체의 역할을 하는 것이 커널 중 디바이스 드라이버이다.</p><p>디바이스 드라이버는 컴퓨터와 연결된 장치를 추상화시키므로 유저 어플리케이션이 정형화된 인터페이스를 통해 장치에 접근할 수 있는 형태의 소프트웨어로 볼 수 있다. 커널이 컴파일될 때 부터 포함된 디바이스 드라이버도 있으며 커널 부팅 후에 로드하는 디바이스 드라이버도 존재한다. 결과적으로 LKM으로 볼 수 있다.</p><br><p><img src="/img/device_driver_list.png"></p><br><h3 id="캐릭터-디바이스-드라이버-chrdev"><a href="#캐릭터-디바이스-드라이버-chrdev" class="headerlink" title="캐릭터 디바이스 드라이버(chrdev)"></a>캐릭터 디바이스 드라이버(chrdev)</h3><p>디바이스를 파일처럼 접근하며 해당 파일의 read/write를 수행하여 data를 stream방식으로 전송한다. 주로 console, keyboard, mouse, serial port driver등의 형태로 사용된다.</p><h3 id="블록-디바이스-드라이버-blkdev"><a href="#블록-디바이스-드라이버-blkdev" class="headerlink" title="블록 디바이스 드라이버(blkdev)"></a>블록 디바이스 드라이버(blkdev)</h3><p>disk와 같은 file system을 기반으로 block 단위로 데이터를 read/write한다. 주로 hard disk, CD ROM driver등에 사용된다. 시스템 버퍼 캐시를 사용한다는 특성을 가지고 있다.</p><h3 id="네트워크-디바이스-드라이버-netdev"><a href="#네트워크-디바이스-드라이버-netdev" class="headerlink" title="네트워크 디바이스 드라이버(netdev)"></a>네트워크 디바이스 드라이버(netdev)</h3><p>network의 물리계층과 frame 단위의 데이터를 송수신하는 드라이버이다. 주로 이더넷 디바이스 드라이버(eth0)등에 사용된다.</p><br><p>유저 어플리케이션 입장에서는 가상 파일 시스템(VFS)를 사용하기 때문에 파일 디스크립터를 통해 특정 파일 접근하여 값을 읽거나(read) 쓰는 형태(write)로 쉽게 하드웨어가 제어가능하다. 이런 의미로 파일로 추상화 시켰다고 볼 수 있으며 정형화 된 인터페이스로 불 수 있다는 것 이다. 하지만 세부적으로 보았을 때 버퍼를 사용한다 사용하지 않는다 등의 특징이 있다.</p><br><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>커널의 종류를 알아보았으며 해당 커널마다 어떠한 특성을 지니고 발생하는 단점을 해결하기 위해 LKM을 학습하였다. LKM으로 사용되는 예시 중 하나인 디바이스 드라이버에 대해서 조사해보았다. 글이 너무 길어져서 직접 디바이스 드라이버를 개발하는 것은 다음 포스트에서 진행하도록 하겠다.</p><br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>As Soon As (ex)Ploit...</code></pre><br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)https://butter-shower.tistory.com/29https://temp123.tistory.com/16https://tribal1012.tistory.com/154http://artoa.hanbat.ac.kr/lecture_data/embedded_sw/04_old.pdf</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (5) 커널에서의 메모리 할당 3편</title>
    <link href="/2021/09/07/LinuxKernelBasic5/"/>
    <url>/2021/09/07/LinuxKernelBasic5/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-5-커널에서의-메모리-할당-3편"><a href="#Research-Linux-Kernel-Basic-5-커널에서의-메모리-할당-3편" class="headerlink" title="[Research] Linux Kernel Basic - (5) 커널에서의 메모리 할당 3편"></a>[Research] Linux Kernel Basic - (5) 커널에서의 메모리 할당 3편</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 리눅스 커널(Linux Kernel)에서도 연산을 수행하기 위해서 데이터가 저장되어야만 하는 공간이 있어야 한다. 이러한 공간의 주체는 메모리(memory)이며 리눅스 커널(Linux Kernel)에서의 메모리의 할당 방식을 알아본다. 이전 포스트에서는 페이지 단위로 메모리를 할당하는 alloc_page에 대해 언급하였고 해당 포스트에서는 작은 메모리 공간 동적 할당에 대한 포스팅을 진행한다.</p><h2 id="페이지-단위-할당의-문제"><a href="#페이지-단위-할당의-문제" class="headerlink" title="페이지 단위 할당의 문제"></a>페이지 단위 할당의 문제</h2><p><img src="/img/internal_frag.PNG" alt="Internal Fragmentation"></p><p>일반적인 리눅스 시스템의 경우는 물리 메모리를 페이지 단위로 관리한다. 메모리 할당과 메모리 해제에 있어서 페이지의 크기인 4KB(0x1000)을 기준으로 이루어진다는 것이다. 일반적으로 사이즈가 페이지 단위에 근접하는 프로그램이 메모리에 로드되어 프로세스가 되는 경우는 문제가 느껴지지 않을 수 있다. 하지만 커널의 경우에서도 작은 사이즈의 메모리의 동적할당이 필요한 경우가 있을 것이다. 만약 32바이트의 메모리가 필요한 경우에 다음과 같이 페이지 단위로 관리하게 된다면 엄청난 양의 Internal Fragmentation이 발생한다. 더 나아가 빈번한 할당과 해제는 속도에 있어서도 매우 비효율적이다. 이러한 특성들은 메모리의 관리를 페이지 단위로 하기에 발생하는 특성이며 다음 언급할 내용은 이러한 문제를 해결하는 방법이다.</p><h2 id="슬랩-할당자-Slab-Allocator"><a href="#슬랩-할당자-Slab-Allocator" class="headerlink" title="슬랩 할당자(Slab Allocator)"></a>슬랩 할당자(Slab Allocator)</h2><p>슬랩 할당자의 개념을 이해하기 위해서는 커널 개발자가 되었다고 가정해보겠다. 운영체제를 사용하며 프로세스를 시작하거나 하는 등의 일들을 진행할 수 있다. 그 과정에서 다음과 같은 특성을 발견하였다.</p><pre><code>특정한 크기를 가진 메모리가 할당과 해제를 반복한다.</code></pre><p>이러한 특성을 이용하면 보다 효율적인 메모리 할당 시스템을 구현할 수 있다.</p><pre><code>자주 쓰는 메모리 패턴을 정의한 후 미리 할당해 놓는다.해당 패턴에 대한 메모리 할당 요청이 발생할 경우 할당해 놓은 메모리를 사용하게 한다.해당 패턴에 대한 메모리 해제 요청이 발생하면 해제하지 않고 대기한다. 다시 해당 패턴으로 메모리 할당 요청을 할 가능성이 높다.</code></pre><p>해당 구조를 메모리 풀(memory pool) 구조라고 한다. b30w0lf님의 운영체제 시간에 잠깐 여러가지 공을 수영장에 넣어두었다가 준다는 클립 아트를 보았었는데 그것이 바로 이것이다!</p><p>이러한 형태의 메모리 관리 구조를 <u>슬랩 메모리 할당</u>이라고 한다.</p><h2 id="슬랩-캐시-슬랩-오브젝트-슬랩-페이지"><a href="#슬랩-캐시-슬랩-오브젝트-슬랩-페이지" class="headerlink" title="슬랩 캐시, 슬랩 오브젝트, 슬랩 페이지"></a>슬랩 캐시, 슬랩 오브젝트, 슬랩 페이지</h2><h3 id="슬랩-캐시-Slab-Cache"><a href="#슬랩-캐시-Slab-Cache" class="headerlink" title="슬랩 캐시(Slab Cache)"></a>슬랩 캐시(Slab Cache)</h3><p>슬랩 메모리 할당방식을 이야기하며 언급하고 넘어가야 하는 개념이 있다. 슬랩 캐시(Slab Cache), 슬랩 오브젝트(Slab Object), 슬랩 페이지(Slab Page)에 관한 내용이다. </p><p>슬랩 캐시(Slab Cache)란 일종의 슬랩 메모리 할당을 하며 관리하는 주체인 매니저와 같은 형태라고 볼 수 있다. 예를 들어 특정 바이트 만큼의 메모리 할당 요청이 들어올 경우 이를 제공해주고 할당 해제한 슬랩 메모리를 받아서 다시 요청이 들어올 경우 이를 내어주는 주체가 슬랩 캐시라고 보면 된다.</p><pre><code>ray@ubuntu:~/Kernel/device_driver$ sudo cat /proc/slabinfo slabinfo - version: 2.1# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;mm_struct            180    180   1088   30    8 : tunables    0    0    0 : slabdata      6      6      0task_struct          940    955   6080    5    8 : tunables    0    0    0 : slabdata    191    191      0.kmalloc-512        21464  21632    512   64    8 : tunables    0    0    0 : slabdata    338    338      0kmalloc-256         4843   5248    256   64    4 : tunables    0    0    0 : slabdata     82     82      0kmalloc-192         2058   2058    192   42    2 : tunables    0    0    0 : slabdata     49     49      0kmalloc-128         1472   1472    128   64    2 : tunables    0    0    0 : slabdata     23     23      0kmalloc-96          6029   6300     96   42    1 : tunables    0    0    0 : slabdata    150    150      0kmalloc-64         12318  12800     64   64    1 : tunables    0    0    0 : slabdata    200    200      0kmalloc-32         11050  11136     32  128    1 : tunables    0    0    0 : slabdata     87     87      0kmalloc-16         10240  10240     16  256    1 : tunables    0    0    0 : slabdata     40     40      0kmalloc-8          13312  13312      8  512    1 : tunables    0    0    0 : slabdata     26     26      0</code></pre><p>다음의 명령어를 통해 슬랩 캐시를 확인할 수 있다. 해당 결과를 보면 익숙한 구조체인 task_struct, mm_struct등이 보이며 kmalloc-n과 같은 형태의 n바이트의 메모리에 대한 슬랩 캐시들이 존재하는 것을 확인할 수 있다. 다음과 같은 캐시들이 슬랩 메모리를 관리하는 주체이다. 하나의 슬랩 캐시(Slab Cache)내의 모든 메모리들은 동일한 사이즈로 제공된다는 사실을 알고 있자.</p><h3 id="슬랩-오브젝트-Slab-Object-와-슬랩-페이지-Slab-Page"><a href="#슬랩-오브젝트-Slab-Object-와-슬랩-페이지-Slab-Page" class="headerlink" title="슬랩 오브젝트(Slab Object)와 슬랩 페이지(Slab Page)"></a>슬랩 오브젝트(Slab Object)와 슬랩 페이지(Slab Page)</h3><p><img src="/img/slab_sample.PNG"></p><p>슬랩 오브젝트(Slab Object)란 슬랩 캐시가 미리 확보해 놓은 메모리를 의미하며 이러한 오브젝트들로 구성된 페이지를 슬랩 페이지(Slab Page)라고 한다. 결과적으로 슬랩 페이지 또한 페이지이며 4KB의 크기를 갖는다. 상단의 그림을 확인해보면 특정한 크기로 미리 확보해 놓은 메모리가 슬랩 객체(Slab Object)임을 확인할 수 있으며 해당 메모리가 사용되는 경우는 Alloc으로 마킹되어 있으며 사용하지 않는 경우는 Free로 마킹되어 있는 것을 확인할 수 있다. 이러한 슬립 객체들이 모여서 슬랩 페이지를 구성하고 있음을 볼 수 있다.</p><p>Free된 슬랩 객체의 경우는 freelist라는 리스트 자료구조로 관리되며 이를 통해 해당 메모리에 대해 요청이 들어올 경우 이를 확인하여 슬랩 객체의 주소를 반환할 수 있다.</p><h2 id="커널-코드-분석"><a href="#커널-코드-분석" class="headerlink" title="커널 코드 분석"></a>커널 코드 분석</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">static __always_inline void *kmalloc(size_t size, gfp_t flags)<br>&#123;<br>        if (__builtin_constant_p(size)) &#123;<br>#ifndef CONFIG_SLOB<br>                unsigned int index;<br>#endif<br>                if (size &gt; KMALLOC_MAX_CACHE_SIZE)<br>                        return kmalloc_large(size, flags);<br>#ifndef CONFIG_SLOB<br>                index = kmalloc_index(size);<br><br>                if (!index)<br>                        return ZERO_SIZE_PTR;<br><br>                return kmem_cache_alloc_trace(<br>                                kmalloc_caches[kmalloc_type(flags)][index],<br>                                flags, size);<br>#endif<br>        &#125;<br>        return __kmalloc(size, flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>kmalloc 함수를 확인하면 내부적으로 kmem_cache_alloc_trace를 호출함을 확인할 수 있다.<br><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)<br>&#123;<br>void *ret = slab_alloc(s, gfpflags, _RET_IP_);<br>trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags);<br>kasan_kmalloc(s, ret, size, gfpflags);<br>return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>kmem_cache_alloc_trace 함수는 slab_alloc함수에 kmem_cache와 gfpflags, 주소인 address를 전달함을 확인할 수 있다.<br><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">static __always_inline void *slab_alloc(struct kmem_cache *s,<br>gfp_t gfpflags, unsigned long addr)<br>&#123;<br>return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>slab_alloc 함수는 slab_alloc_node 함수를 호출함을 알수 있다.<br><br></p><p>slab_alloc_node의 경우는 코드의 중요한 부분만 오디팅하여 작성하겠다. slab_alloc_node 함수는 다음과 같은 로직을 진행한다.</p><pre><code>STEP1. kmem_cache_cpu 구조체로 관리되는 per-cpu 슬럽 캐시를 로딩한다.STEP2. per-cpu 슬랩 캐시의 속성 중 struct page 타입인 page에 접근한다.STEP3. 슬랩 오브젝트를 할당한다.    kmem_cache_cpu 중 freelist에 해제된 슬랩 객체가 있는 경우             해당 슬랩객체를 반환한다.    kmem_cache_cpu 중 freelist에 어떠한 객체도 존재하지 않는 경우              __slab_alloc() 함수를 호출하여 새로운 슬랩 페이지를 할당한다.             할당된 슬랩 페이지에서의 슬랩 객체를 반환한다.</code></pre><h2 id="슬랩-Slab-슬럽-Slob-슬롭-Slub"><a href="#슬랩-Slab-슬럽-Slob-슬롭-Slub" class="headerlink" title="슬랩(Slab), 슬럽(Slob), 슬롭(Slub)"></a>슬랩(Slab), 슬럽(Slob), 슬롭(Slub)</h2><p>슬랩과 슬럽 슬롭은 모두 메모리 할당자이다. 메모리를 미리 만들어 할당하는 형태의 큰 아이디어에서는 변화가 없음으로 동일한 형태로 보아도 무방하다고 조심스럽게 얘기한다. 현재 기준으로는 기본 할당자로 슬럽(Slub)을 사용하고 있다. 슬롭(Slob)의 경우는 지정한 사이즈 내 객체의 메모리 할당은 모두 처리하는 메모리 할당자라고 한다. 메모리를 할당할 경우 속도는 가장 느리나 메타 데이터와 같은 부가 정보가 필요하지 않아 메모리 소모가 적어 임베디드에 적용이 된다고 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>3편에 걸쳐 리눅스 커널에서의 메모리 할당 방식을 알아보았다. 다음 편에서는 실제 디바이스 드라이버를 구현하는 모듈 프로그래밍에 대해서 진행해보도록 하겠다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)http://egloos.zum.com/rousalome/v/10001242https://jiravvit.tistory.com/entry/linux-kernel-4-슬랩할당자</code></pre>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (4) 커널에서의 메모리 할당 2편</title>
    <link href="/2021/09/07/LinuxKernelBasic4/"/>
    <url>/2021/09/07/LinuxKernelBasic4/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-4-커널에서의-메모리-할당-2편"><a href="#Research-Linux-Kernel-Basic-4-커널에서의-메모리-할당-2편" class="headerlink" title="[Research] Linux Kernel Basic - (4) 커널에서의 메모리 할당 2편"></a>[Research] Linux Kernel Basic - (4) 커널에서의 메모리 할당 2편</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 리눅스 커널(Linux Kernel)에서도 연산을 수행하기 위해서 데이터가 저장되어야만 하는 공간이 있어야 한다. 이러한 공간의 주체는 메모리(memory)이며 리눅스 커널(Linux Kernel)에서의 메모리의 할당 방식을 알아본다. 포스트 작성에 앞서 오늘의 미팅에서 배웠던 이야기 주제로 자료조사를 진행하며 작성하며 b30W0lf님은 매우 잘 가르쳐주셨지만 무지성 침팬지 나의 두뇌 때문에 잘못된 내용이 있을 수 있음을 밝힌다.</p><h2 id="리눅스-시스템에서의-메모리-할당"><a href="#리눅스-시스템에서의-메모리-할당" class="headerlink" title="리눅스 시스템에서의 메모리 할당"></a>리눅스 시스템에서의 메모리 할당</h2><p>일반적인 리눅스 시스템의 경우는 물리적 메모리를 가지고 있으며 이를 프로세스가 사용할 수 있도록 페이지의 단위로 할당한다. 페이지의 경우는 일반적으로 4KB(0x1000)의 크기를 가지고 있다. 이는 alloc_pages() 함수를 이용해 할당받을 수 있다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)<br>&#123;<br>struct page *page;<br><br>page = alloc_pages(gfp_mask &amp; ~__GFP_HIGHMEM, order);<br>if (!page)<br>return 0;<br>return (unsigned long) page_address(page);<br>&#125;<br></code></pre></td></tr></table></figure><p>해당 코드는 /mm/page_alloc.c에서 확인할 수 있다. 해당 코드 내부에 Line5에는 alloc_pages라는 함수를 확인할 수 있으며 이는 <u>물리 메모리에서의 페이지를 할당 받는 함수</u>이다. 해당 함수의 경우 파라미터로 gfp_mask와 order를 전달하는 것을 확인할 수 있다. 예를 들어 0을 넘기게될 경우 0x1000(4096) 메모리를 할당받고 1을 넘기게 될 경우 0x2000(8192) 메모리를 할당받고 2를 넘기게 될 경우 0x4000(16384)만큼의 메모리를 할당받는다. 이를 살펴보면 2의 제곱의 형태로 페이지를 할당받는 것을 확인할 수 있다. 왜 다음과 같은 형태로 메모리를 할당받을까?</p><p><img src="/img/buddy_meme.PNG" alt="와썹 버디!"></p><p>이는 운영체제 수업에서 언급하였던 Buddy Memory Allocation과 관련이 있다고 판단된다. 원시적(primitive)인 방법을 통해서 메모리를 필요한 공간만큼 지속적으로 할당한 후 이를 더 이상 사용하지 않는다고 판단되어 해제할 경우 해당 프로세스의 메모리 만큼의 빈 공간(Hole)이 발생하며 지속적으로 이러한 형태들이 단편화가 진행된다면 빈 공간은 필요한 메모리 크기 이상으로 존재하나 적재될 수 없는 External Fragmentation의 상황이 발생한다.</p><p><img src="/img/buddy_sample.jpg" alt="Buddy Memory Allocator"></p><p>이러한 문제점을 해결하기 위한 여러가지 방법이 있으나 지정된 크기를 짝을 지어 할당하거나 해제하여 다시 합치는 Buddy Memory Allocator가 있다. 일반적으로 현재의 시스템의 대다수는 Buddy Memory Allocator 형태로 메모리 관리를 진행한다. 이는 상단의 그림을 확인하면 보다 직관적으로 이해할 수 있다. </p><p>다음의 경우는 페이지의 단위(4KB)를 기준으로 메모리를 할당하기에 대용량의 버퍼를 사용하는 경우나 메모리 풀을 관리하는 경우에는 다음과 같은 형태로 메모리를 할당한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>다음은 페이지 단위로 메모리를 할당하는 리눅스 시스템을 확인하였고, 서로 짝을 지어 분할하거나 합쳐서 메모리를 해제하는 형태의 Buddy System Allocation을 확인하였다. 그렇다면 대용량의 버퍼가 아닌 커널에서의 구조체의 정보를 담기 위한 작은 사이즈(16Byte, 32Byte, …)등의 메모리를 할당하기 위해서는 어떠한 기법이 적용되어 있는 지 다음 포스트에서 확인해보겠다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편</title>
    <link href="/2021/09/06/LinuxKernelBasic3/"/>
    <url>/2021/09/06/LinuxKernelBasic3/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-3-커널에서의-메모리-할당-1편"><a href="#Research-Linux-Kernel-Basic-3-커널에서의-메모리-할당-1편" class="headerlink" title="[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편"></a>[Research] Linux Kernel Basic - (3) 커널에서의 메모리 할당 1편</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 리눅스 커널(Linux Kernel)에서도 연산을 수행하기 위해서 데이터가 저장되어야만 하는 공간이 있어야 한다. 이러한 공간의 주체는 메모리(memory)이며 리눅스 커널(Linux Kernel)에서의 메모리의 할당 방식을 알아본다.</p><h2 id="정적-메모리"><a href="#정적-메모리" class="headerlink" title="정적 메모리"></a>정적 메모리</h2><p>커널에서의 정적 메모리 할당에 대하여 구체적으로 알아보려고 한다. 유저 공간의 할당과 마찬가지로 정적 메모리 할당은 특징을 지닌다.</p></br><pre><code>1. 함수 호출 시 함수 프롤로그의 절차를 통해 스택에 공간을 할당한다.2. 유저 공간과는 별개의 커널의 스택 공간이 할당된다.3. 컴파일 시 스택 공간에 얼마만큼의 데이터를 활용할 것인지에 관해 결정된다.4. 함수 호출 시 함수 에필로그의 절차를 통해 정적 메모리는 자동으로 해제된다.</code></pre><p>위의 기재된 내용은 일반적인 유저공간의 스택공간의 할당과 동일해보인다. 부가적인 내용을 붙히자면 컴파일을 통해 스택 프레임의 최상위에서 sub연산을 통해 공간을 확보하고 함수 호출이 종료되는 시점에서 스택 프레임의 최상위에서 add연산을 통해 프레임을 해제한다. 이 후 함수가 호출되어도 스택 포인터(frame pointer)와 베이스 포인터(base pointer)를 기준으로 접근하기에 일반적인 경우라면 문제 발생의 소지가 없다.</p></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task) &#123;<br>    int prio, oldprio, queued, running, queue_flag =<br>        DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;<br>    const struct sched_class *prev_class;<br>    struct rq_flags rf;<br>    struct rq *rq;<br><br>    prio = __rt_effective_prio(pi_task, p-&gt;normal_prio);<br>    ...<br></code></pre></td></tr></table></figure><p>다음의 코드를 확인하면 8개의 변수를 활용하는 것을 알 수 있다.</p></br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">&lt;rt_mutex_setprio&gt;:<br>    e1a0c00d movip, sp<br>    e92ddff0 push&#123;r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc&#125;<br>    e24cb004 subfp, ip, #4<br>    e24dd014 subsp, sp, #20<br>    .<br>    .<br>    .<br></code></pre></td></tr></table></figure><p>해당 함수의 어셈블리 코드를 확인하면 레지스터 {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}를 스택 공간에 push하며 sub sp, sp, #20을 통해 스택의 20바이트의 공간 만큼을 확보한다. 이 때 사용되는 지역변수의 개수는 8개이며 32바이트 만큼의 공간을 확보해야 한다고 의문이 드나 이는 내부적으로 레지스터를 활용하는 방안으로 진행되지 않았을까라고 조심스럽게 판단한다. 자세한 부분은 b30w0lf님께 여쭤봐야 할 것으로 보인다.</p><h2 id="동적-메모리"><a href="#동적-메모리" class="headerlink" title="동적 메모리"></a>동적 메모리</h2><p>커널에서의 동적 메모리 할당에 대하여 구체적으로 알아보려고 한다. 커널에서의 메모리 할당은 kmalloc() 함수를 이용하여 동적 메모리를 할당한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">static ssize_t regmap_read_debugfs(struct regmap *map, unsigned int from,<br>   unsigned int to, char __user *user_buf, size_t count, loff_t *ppos)<br>    &#123;<br>    ...<br>    if (*ppos &lt; 0 || !count)<br>    return -EINVAL;<br><br>    buf = kmalloc(count, GFP_KERNEL);<br>    if (!buf)<br>    return -ENOMEM;<br></code></pre></td></tr></table></figure><p>상단의 코드를 확인하면 kmalloc() 함수를 볼 수 있으며 해당 함수는 두 개의 인자 count와 GFP_KERNEL이 전달되는 것을 확인할 수 있다. 종합해 코드를 해석하면 GFP_KERNEL 옵션을 통해 count 바이트 만큼 동적 메모리를 할당한다라는 의미이다. kmalloc을 이용하면 커널 내부 메모리 시스템의 경우 커널 내부에 할당할 동적 메모리가 있으면 최대한 할당해준다고 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>정적 메모리의 할당은 유저 공간(user space)에서의 스택 공간할당은 커널 메모리 공간에 할당된다. 이외에는 크게 다른 점이 없어보이며 동적 메모리 할당은 kmalloc() 함수를 사용한다이다. 단 의아한 부분이 커널 내부에 할당할 동적 메모리가 있으면 최대한 할당해준다고 하는 의미인다. 이는 슬랩(slab)에 대한 개념을 익혀야 더욱 깊게 이해가 가능할 것으로 보인다.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><p><a href="http://rousalome.egloos.com/10002615">http://rousalome.egloos.com/10002615</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (2) 태스크(task)</title>
    <link href="/2021/09/05/LinuxKernelBasic2/"/>
    <url>/2021/09/05/LinuxKernelBasic2/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-2-태스크-task"><a href="#Research-Linux-Kernel-Basic-2-태스크-task" class="headerlink" title="[Research] Linux Kernel Basic - (2) 태스크(task)"></a>[Research] Linux Kernel Basic - (2) 태스크(task)</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>지난 포스트에서는 리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대해 간략히 언급하였다. 해당 포스트에서는 운영체제(Operating System)에서 다뤄지는 프로세스(prcoess)와 스레드(thread)를 정의하는 구조인 태스크(task)를 커널 소스코드 분석을 통해 심도있게 이해하고 해당 과정을 통해 어떠한 방식으로 권한확대(Local Privilege Escalation)를 일으킬 수 있는 가에 관한 인사이트를 얻기 위한 연구를 진행하였다.</p><h2 id="프로세스-proces-및-스레드-thread"><a href="#프로세스-proces-및-스레드-thread" class="headerlink" title="프로세스(proces) 및 스레드(thread)"></a>프로세스(proces) 및 스레드(thread)</h2><pre><code>$ ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:50 ?        00:00:02 /sbin/init auto nopromptroot          2      0  0 01:50 ?        00:00:00 [kthreadd]root          3      2  0 01:50 ?        00:00:00 [rcu_gp]root          4      2  0 01:50 ?        00:00:00 [rcu_par_gp]root          6      2  0 01:50 ?        00:00:00 [kworker/0:0H-kb]root          9      2  0 01:50 ?        00:00:00 [mm_percpu_wq]root         10      2  0 01:50 ?        00:00:00 [ksoftirqd/0]root         11      2  0 01:50 ?        00:00:00 [rcu_sched]root         12      2  0 01:50 ?        00:00:00 [migration/0]root         13      2  0 01:50 ?        00:00:00 [idle_inject/0]</code></pre><p>리눅스를 사용하다보면 다음과 같은 명령어를 통해 프로세스의 정보를 확인해야하는 경우가 발생한다. 프로세스의 정보를 확인하면 어떠한 프로세스인지, 프로세스의 번호는 몇번인지, 어떠한 권한으로 동작을 진행하는지에 관한 정보들을 확인할 수 있다. 리눅스에서는 프로세스에 종속되어 새로운 실행의 흐름을 생성하는 스레드(thread)의 경우에도 하나의 프로그램의 실행단위로 볼 수 있으며 이러한 단위를 태스크(task)라고 한다.</p><h2 id="태스크-task"><a href="#태스크-task" class="headerlink" title="태스크(task)"></a>태스크(task)</h2><p>리눅스 운영체제의 경우 컴퓨터가 해야할 작업의 단위인 여러 개의 태스크(task)를 생성하며 다수의 태스크를 관리(multitasking)하며 이러한 태스크의 실행 시간을 배분하는 방식(scheduling)을 통해 사용자가 다수의 프로그램을 정상적으로 사용할 수 있도록 한다. 태스크를 관리하기 위해서는 여러가지 정보가 필요하다. 이는 앞서 제시하였던 명령어의 결과로 일부를 확인할 수 있다. 이러한 정보는 task_struct 구조체에 정의되어 있으며 해당 구조체는 &lt;include/linux/sched.h&gt;에서 확인할 수 있다.</p><h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct task_struct &#123;<br>    ...<br>unsigned int__state;<br>struct list_headtasks;<br>    struct mm_struct*mm;<br>pid_tpid;<br>pid_ttgid;<br>struct task_struct __rcu*real_parent;<br>struct task_struct __rcu*parent;<br>const struct cred __rcu*cred;<br>charcomm[TASK_COMM_LEN];<br>struct files_struct*files;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>__state</td><td>해당 태스크의 실행상태를 나타낸다. 0은 실행 중이거나 실행 가능한(ready) 상태를 표현한다. 0보다 큰 값의 경우는 정지 또는 대기 상태를 표현한다.</td></tr><tr><td>tasks</td><td>태스크의 연결 노드를 의미한다.</td></tr><tr><td>mm</td><td>mm_struct는 유저의 메모리 영역(주소공간)에 관한 정보를 나타내는 구조체이다. 해당 태스크의 주소공간의 정보를 나타낸다.</td></tr><tr><td>pid</td><td>프로세스의 식별값을 의미한다.</td></tr><tr><td>tgid</td><td>스레드 그룹의 식별값을 의미한다.</td></tr><tr><td>real_parent</td><td>해당 태스크를 생성한 부모 태스크를 나타낸다.</td></tr><tr><td>parent</td><td>해당 태스크의 현재 부모 태스크를 나타낸다.</td></tr><tr><td>cred</td><td>해당 태스크의 신원 정보를 나타낸다.</td></tr><tr><td>comm[TASK_COMM_LEN]</td><td>해당 태스크의 이름을 나타낸다.</td></tr><tr><td>files</td><td>해당 태스크에서 열린 파일 디스크립터 정보를 나타낸다.</td></tr></tbody></table><h3 id="cred"><a href="#cred" class="headerlink" title="cred"></a>cred</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">struct cred &#123;<br>atomic_tusage;<br>    ...<br>kuid_tuid;/* real UID of the task */<br>kgid_tgid;/* real GID of the task */<br>kuid_tsuid;/* saved UID of the task */<br>kgid_tsgid;/* saved GID of the task */<br>kuid_teuid;/* effective UID of the task */<br>kgid_tegid;/* effective GID of the task */<br>kuid_tfsuid;/* UID for VFS ops */<br>kgid_tfsgid;/* GID for VFS ops */<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>속성(property)</th><th>설명(description)</th></tr></thead><tbody><tr><td>usage</td><td>몇 개의 프로세스가 해당 cred 구조체를 참조하고 있는 지 나타낸 정보이다.</td></tr><tr><td>uid</td><td>프로세스를 소유하고 있는 사용자의 ID를 나타낸 정보이다. 0일 경우 최고관리자 권한을 의미한다.</td></tr><tr><td>euid</td><td>프로세스의 실효적인 사용자 ID를 나타낸 정보이다. 권한 검사를 할 경우 실제 사용되는 값을 저장한다. 일반적으로 uid와 같은 값을 가진다.</td></tr><tr><td>gid</td><td>프로세스를 소유하 고 있는 그룹의 ID 정보를 나타낸다.</td></tr><tr><td>egid</td><td>프로세스의 실효적인 그룹의 ID 정보를 나타낸다.</td></tr></tbody></table><h2 id="credential-정보-수정을-통한-권한-상승"><a href="#credential-정보-수정을-통한-권한-상승" class="headerlink" title="credential 정보 수정을 통한 권한 상승"></a>credential 정보 수정을 통한 권한 상승</h2><p>앞서 진행한 과정을 통해 프로세스와 스레드는 태스크라는 단위로 관리되어 있고 태스크의 정보 속성을 관리하는 주체가 있으며 신원정보는 cred라는 구조체에서 관리되고 있음을 알 수 있다. 그렇다면 태스크의 신원정보를 변경하였을 경우 권한 상승(Local Privilege Escalation)이 이뤄질 수 있는 지 확인하겠다. </p><p>해당 실습은 Dreamhack에서 제시하는 실습 파일을 이용하여 진행하였음을 밝힌다.</p><pre><code>dreamhack@dh-lke:~$ whoamidreamhackdreamhack@dh-lke:~$ cat /etc/shadowcat: /etc/shadow: Permission denieddreamhack@dh-lke:~$ echo $$295dreamhack@dh-lke:~$ ...</code></pre><p>qemu를 이용하여 터미널을 실행하였을 경우 다음과 같이 root 권한이 아니기 때문에 /etc/shadow 파일을 볼 수 없는 것을 확인할 수 있으며 해당 쉘의 프로세스 아이디(PID)는 295로 확인된다.</p><pre><code>pwndbg&gt; x/bs $lx_task_by_pid(295).comm0xffff88803e348a98:    &quot;bash&quot;pwndbg&gt; print $lx_task_by_pid(295).state$1 = 1pwndbg&gt; print $lx_task_by_pid(295).cred-&gt;uid$2 = &#123;    val = 1000&#125;pwndbg&gt; set $lx_task_by_pid(295).cred-&gt;euid = 0pwndbg&gt; cont</code></pre><p>해당 프로세스의 아이디를 이용하여 해당 태스크의 정보를 확인해본 결과 해당 프로세스는 실행중인 프로세스이며 uid가 1000으로 지정되어 있다. 이를 의도적으로 0으로 수정해보았다.</p><pre><code>dreamhack@dh-lke:~$ whoamirootdreamhack@dh-lke:~$ cat /etc/shadowroot:*:18511:0:99999:7:::daemon:*:18511:0:99999:7:::bin:*:18511:0:99999:7:::sys:*:18511:0:99999:7:::sync:*:18511:0:99999:7:::games:*:18511:0:99999:7:::man:*:18511:0:99999:7:::lp:*:18511:0:99999:7:::mail:*:18511:0:99999:7:::</code></pre><p>해당 과정을 수행해본 결과 해당 프로세스는 최고 관리자 권한(root)를 획득하였음을 볼 수 있다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>프로세스(process)와 스레드(thread)는 태스크 관리로 운영되며 태스크의 속성을 표현하는 정보가 있다. 해당 정보 중에는 프로세스의 신원정보를 의미하는 cred 구조체 형태의 정보가 있으며 이를 조작하여 최고관리자 권한을 얻을 수 있다. 태스크의 정보는 커널 메모리의 상주하며 커널의 취약점을 이용한다면 권한상승(Local Privilege Escalation)이 발생할 수 있음을 보인다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</title>
    <link href="/2021/09/04/LinuxKernelBasic1/"/>
    <url>/2021/09/04/LinuxKernelBasic1/</url>
    
    <content type="html"><![CDATA[<h2 id="Research-Linux-Kernel-Basic-1-유저모드와-커널모드"><a href="#Research-Linux-Kernel-Basic-1-유저모드와-커널모드" class="headerlink" title="[Research] Linux Kernel Basic - (1) 유저모드와 커널모드"></a>[Research] Linux Kernel Basic - (1) 유저모드와 커널모드</h2><p><img src="/img/penguinshot.png"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>리눅스 커널 공격(Linux Kernel Exploitation)을 진행하기 위해서는 리눅스 커널(Linux Kernel)에 대한 이해가 먼저 선행되어야 한다. 하지만 리눅스 커널(Linux Kernel)은 일반적으로 접근한다면 오픈소스의 특성인 집단지성의 결정체라고 할 수 있을만큼 매우 방대하며 모든 것을 학습을 할 수 없다. 그러므로 리눅스 커널 공격(Linux Kernel Exploitation)을 위한 기초적인 운영체제의 지식을 기반으로하여 프로세스의 메모리 구조, 유저모드(user mode)와 커널모드(kernel mode), 커널의 공격할 수 있는 부분(attack surface)가 될 수 있는 많은 부분 중 쉽게 구현할 수 있는 디바이스 드라이버(device driver)를 기반으로 연구를 진행했다.</p><h2 id="커널-kernel-이란"><a href="#커널-kernel-이란" class="headerlink" title="커널(kernel)이란"></a>커널(kernel)이란</h2><p><img src="/img/arch.png"></p><p>공격할 대상은 리눅스 커널(linux kernel)이다. 그렇다면 커널(kernel)이 무엇인지 확인하고 넘어갈 필요가 있다. 컴퓨터(computer)는 흔히 알고 있는 전기적으로 제어할 수 있는 CPU, Memory, Devices들로 이루어진 일종의 기계장치(machine)으로 볼 수 있다. 기계란 어떠한 방식으로 동작되는 지 사람이 지정해주어야 하며 기계의 특성상 프로그램을 실행할 수 있도록 섬세하게 조정이 되어야 한다. 그렇지 않다면 단순한 실리콘 덩어리들의 불과하다. 다음과 같은 이유를 고려하면 어떻게 이러한 실리콘 덩어리를 잘 활용하여야 흔히 사용하는 프로그램을 돌리기 위해서는 어떠한 동작이 정의되어 있어야 한다. 커널(kernel)은 다음과 같은 역할을 하기에 중간계층이라고도 많이 불리운다.</p><h2 id="메모리-memory-란"><a href="#메모리-memory-란" class="headerlink" title="메모리(memory)란"></a>메모리(memory)란</h2><p><img src="/img/process_memory.png"></p><p>프로그램이 실행되기 위해서는 보조기억장치(HDD, SSD등)에서 주기억장치(RAM)에 로드 되어야 한다. 하나의 프로세스가 로드되면 32bit를 예시로 총 4GB의 가상메모리 공간에 위치하게 된다. 상단에 제시한 그림과 같은 형태를 나타낸다. 상위 주소(0xC0000000 ~ 0xFFFFFFFF)에는 커널의 위치한 주소가 되며 하위 주소(0x00000000~0xBFFFFFFFF)에는 흔히 알고 있는 유저 프로세스가 로드된다. 커널의 경우는 앞서 언급한 것과 같이 하드웨어의 직접적으로 접근할 수 있는 중요한 부분이며 이러한 이유로 스택 메모리를 확인하면 높은 주소에서 낮은 주소로 데이터가 쓰이는 것을 볼 수 있다.</p><h2 id="커널의-권한"><a href="#커널의-권한" class="headerlink" title="커널의 권한"></a>커널의 권한</h2><p><img src="/img/two_rise_sun.PNG" alt="하늘아래 태양은 두개가 될 수 없는 법."></p><p>커널은 프로세스들을 관리하기도 하고 주요한 정보들이 위치하기에 일반적으로 높은 권한을 지니고 있다. 그럼 다른 이야기를 해보자! 서로 친해지기 위해서 술게임을 하며 왕게임을 하는 데 가학적 성격장애가 있는 친구에게 권력이 부여된다면 타겟들은 인생이 힘들어진다. 또한 아무나 왕이 될 수 있다고하면 배가 산으로 가게되며 시스템 상에서는 아주 큰 문제가 발생할 수 있다. 그러므로 시스템에서는 특권을 지닌 커널 모드와 제한된 권한인 유저 모드로 나누어져 있다.</p><h2 id="커널에게-일을-시키고-싶어-시스템콜-syscall"><a href="#커널에게-일을-시키고-싶어-시스템콜-syscall" class="headerlink" title="커널에게 일을 시키고 싶어 - 시스템콜(syscall)"></a>커널에게 일을 시키고 싶어 - 시스템콜(syscall)</h2><p><img src="/img/systemcall.PNG"></p><p>그렇다면 어떻게 하면 커널을 공격할 수 있을 지 고민해보아야 한다. 일반적으로 유저 권한을 지닌 사용자 어플리케이션을 생각해보면 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 커널도 마찬가지이다. 커널에서의 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 이를 공격 표면(attack surface)라고 불린다. 가장 손쉽게 접근이 가능한 부분은 시스템 콜(syscall)이라고 볼 수 있다. 유저 모드에서는 직접적으로 컴퓨터의 중요 자원에 접근할 수 없기 때문에 커널 모드로의 전환이 일어나야 한다. 흔히 사용하는 printf와 같이 화면에 출력을 하는 함수의 경우도 저수준 함수로 변환되어 커널에게 시스템 콜이라는 인터럽트(interrupt)를 발생시키게 된다. </p><h2 id="커널의-공격-대상-attack-vector"><a href="#커널의-공격-대상-attack-vector" class="headerlink" title="커널의 공격 대상(attack vector)"></a>커널의 공격 대상(attack vector)</h2><p>커널의 주요한 자원에 접근하기 위해서는 직접적으로 접근할 수 없으며 시스템 콜과 같은 간접적인 형태로 접근할 수 있음을 언급하였다. 또한 정의된 시스템 콜 이외에도 리눅스의 경우 디바이스 드라이버 또는 파일 시스템이 모두 커널 모드에서 동작된다. 이러한 요소들까지 고려하면 리눅스의 attack surface의 경우는 시스템 콜 뿐만이 아닌 블루투스 디바이스 드라이버와 같은 많은 형태로 확장이 가능하다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exploit</tag>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>mitigation</tag>
      
      <tag>kaslr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Etc] G4EG4EG4E는 왜 이 블로그를 만들었는가?</title>
    <link href="/2021/09/03/gaelog-introduction/"/>
    <url>/2021/09/03/gaelog-introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험"><a href="#G4EG4EG4E는-왜-이-블로그를-만들었는가-부제-직업체험" class="headerlink" title="G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험"></a>G4EG4EG4E는 왜 이 블로그를 만들었는가? - 부제.직업체험</h2><p><img src="/img/introduction.PNG"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>항상 글은 첫 시작이 어렵다. 글 뿐만 아니라 모든 것이 첫 시작이 어렵다. 기존의 개인적으로 운영하던 블로그가 존재하였으나 너무 시대에 뒤떨어진(?) 플랫폼에서 운영되며 나는 간지로 먹고사는 개발자이기 때문에 유행에 따르게 되어 새로운 블로그를 시작하게 되었다. </p><p>사실은 회사의 마케팅 채널로 기술 블로그를 운영할 시점이기도 하였으며 앞으로 진행할 연구로 인해서 연구노트를 작성해야 하였으며 평소 내가 사모(?)하던 (이하 ‘b40W0lF’)님께서 연구노트처럼 블로그 작성을 권해주셨으며 무한히 신뢰하기 때문에 해당 의견대로 블로그 글을 작성하겠다.</p><p>사랑합니다! 프로페써!!!</p>]]></content>
    
    
    <categories>
      
      <category>Etc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sample1</tag>
      
      <tag>Sample2</tag>
      
      <tag>Sample3</tag>
      
      <tag>Sample4</tag>
      
      <tag>Sample5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
